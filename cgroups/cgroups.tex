\documentclass[a4paper,twoside,12pt]{article}
\usepackage{../z/zed-cm}
\usepackage{graphicx}
\usepackage[nottoc,numbib]{tocbibind}
\markboth{Draft}{Version 0.8 add cgroups api}
\pagestyle{myheadings}
\begin{document}
\parskip 2 pt
\parindent 10 pt

\def\Slash{\slash\hspace{0pt}}

\title{An Abstract Model of Linux Control Groups and Subsystems}

\author{
Glyn Normington\and
Steve Powell
}

\maketitle
% The following three commands ensure the title page is stamped as
% confidential without a page number. Page numbering is started at the
% table of contents.
\thispagestyle{myheadings}
\pagenumbering{roman}
\setcounter{page}{1}

%=============================================================================

This document specifies precisely some of the features of \emph{Linux control groups} and \emph{subsystems} to support robust and reliable development of \emph{Warden}, \emph{Garden} and related products.

\paragraph{Current ``to-do'' list:}
\begin{itemize}
\item \emph{extract improved cgroups description}---derive patch to external docs.
\end{itemize}

% Alt-Cmd-M -- \emph{}
% Alt-Cmd-Z -- \zed{}
% Alt-Cmd-X -- \axdef{}
% Alt-Cmd-S -- \schema{}
% Alt-Shift-Cmd-T -- \texttt{}

% Type checking hacks
\newcommand{\true}{true}
\newcommand{\false}{false}
\renewcommand{\emptyset}{\varnothing}
%=============================================================================

\clearpage
\tableofcontents

\cleardoublepage
\pagenumbering{arabic}

%=============================================================================
\section{Introduction}

In order to implement some features and improvements to \emph{Warden} we sharpen our understanding of Linux control groups
and simultaneously document their use by presenting an abstract model in Z\footnote{See appendix \ref{cha:znot} for a one-page summary of the Z notation.}.

Linux control groups are part of the basis for the current implementation of Warden\cite{warden}\footnote{All references are listed in appendix \ref{sec:references}.} and Garden\cite{garden} as well as of Linux Containers (LXC), Docker, and Google's
\textit{lmctfy} (``let me contain that for you'') project and so are important to the industry at large as well as to Cloud
Foundry.

We intend to use our improved understanding to benefit:
\begin{itemize}
\item Linux Kernel documentation;
\item Warden\cite{warden} and Garden\cite{garden} development and exploitation; and
\item the wider development audience.
\end{itemize}



%=============================================================================
\section{Fundamentals}

We begin by describing some fundamental pieces of our model.

%----------------------------------------------------------------------------------------------------
\subsection{Given sets}
There are fundamental sets of items we will not look into, 
for example $TASK$s\footnote{A \emph{task} is the Linux kernel term for a process.}:
\begin{zed}
[TASK]
\end{zed}
which appear in collections in each control group.

There are $RESOURCE$s, which can be allocated, managed and monitored:
\begin{zed}
[RESOURCE]
\end{zed}
and which we will use to represent our abstract notion of a subsystem.

There are names, of which there are many types, here are two of them:
\begin{zed}
[SIMPLENAME, SSNAME]
\end{zed}
the simple names out of which control group (path)names are formed, and the subsystem names.

%----------------------------------------------------------------------------------------------------
\subsection{Sets of resources}

A subsystem will be concerned with resources, and we will model that by a set associated
with a control group. It is simpler to start with the resource sets by themselves.

There is a $ResourceSet$ type:
\begin{zed}
ResourceSet == \finset RESOURCE
\end{zed}
a piece of state which holds one of them:
\begin{schema}{Resources}
rs : ResourceSet
\end{schema}
and these states begin by being empty:
\begin{zed}
InitResources \defs [ Resources' | rs' = \emptyset ]
\end{zed}

The basic operations not very interesting: simply adding and removing elements, which we expect happens
in batches (sets):

\begin{schema}{AddResources}
rs? : ResourceSet
\also
\Delta Resources
\where
rs' = rs \cup rs?
\end{schema}
where we just stick 'em all in.

\begin{schema}{RemoveResources}
rs? : ResourceSet
\also
\Delta Resources
\where
rs' = rs \setminus rs?
\end{schema}
where we just take 'em all out.

These become more interesting when used in the context of a subsystem, for which see later.

%----------------------------------------------------------------------------------------------------
\subsection{A single control group}

A single control group in isolation is just a (finite) collection of tasks, and we can document this:

\begin{schema}{CGroup}
taskset : \finset TASK
\end{schema}

As a convenience, we define the (global) function $tasks$ which extracts the $taskset$ from a $CGroup$, and the
simple control group $EmptyCGroup$ which has no tasks in it:
\begin{zed}
tasks == (\lambda CGroup @ taskset)
\also
EmptyCGroup == (\mu CGroup | taskset = \emptyset )
\end{zed}

%----------------------------------------------------------------------------------------------------
\subsection{Control group path names}

Control groups have names, but these have a structure---a file directory-like structure---so we define them as \emph{sequences} of simple names (think of these as directory names), for which we use the shorthand $CGPath$:

\begin{zed}
CGPath == \seq SIMPLENAME
\end{zed}

There is a special name for the first (initial) control group, the root of the structure. We define a constant for it:

\begin{axdef}{}
ROOTCGROUPNAME : CGPath
\where
ROOTCGROUPNAME = \langle \rangle
\end{axdef}

There may be many $CGroup$s in the system, and a collection of $CGroup$ with names must `fill out' the tree-structure with $CGPath$ names. We explain this with a $NamedCGroups$ collection:

\begin{schema}{NamedCGroups}
cg : CGPath \ffun CGroup
\where
ROOTCGROUPNAME \in \dom cg \\
\forall s : \dom cg @ \forall t : CGPath | t \subset s @ t \in \dom cg
\end{schema}
The constraints imply that there is  at least one $CGroup$ in the collection (the root) and that the names are `prefix-closed'. The latter constraint is equivalent to saying the names fit together in a tree-structure (as in a file-system).
There is a $CGroup$ for every node in the tree, `named' by the sequence of simple names from the root to the node.

We have said nothing about the \emph{tasks} in the $CGroup$s in the named collection.
This comes next.

%----------------------------------------------------------------------------------------------------
\subsection{System tasks}
In order to describe the relationship between named control groups and tasks, we need a minimal model of the tasks of the system. We first postulate a (fixed) initial task:

\begin{axdef}{}
INITIALTASK : TASK
\end{axdef}
and then we say that the tasks of the system always include this initial task:

\begin{schema}{Tasks}
systasks : \finset TASK
\where
INITIALTASK \in systasks
\end{schema}
which has the (pleasing) consequence that there is always at least one task in the system.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}

When the system tasks are first created, then, this $INITIALTASK$ must exist, which is to say that there is at least one task. We simplify it by saying there is exactly one (though we are not usually around to see this natal state).

\begin{schema}{InitTasks}
Tasks'
\where
\# systasks' = 1
\end{schema}
We may not need to use this property directly.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Creating a new task---lowest level}

We do need to speak about new task creation later, and so here is how we model it, from the point of view of $Tasks$:

\begin{schema}{CreateTask}
parent? : TASK \\
task! : TASK
\also
\Delta Tasks
\where
parent? \in systasks \\
task! \notin systasks \\
systasks' = systasks \cup \{ task! \}
\end{schema}
The new task has to have a (designated) parent, which is just any existing system task; the new task is not already
in the system and is inserted into the system, without disturbing any other tasks.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Destroying a task---lowest level}

Task destruction is also needed later in the context of control groups, but from the point of view of $Tasks$ we can say:

\begin{schema}{DestroyTask}
task? : TASK
\also
\Delta Tasks
\where
task? \in systasks \\
task? \neq INITIALTASK \\
systasks'  = systasks \setminus \{ task? \}
\end{schema}
The task being destroyed is already in the system; it must not be the system's initial task
(this constraint could have been \emph{derived} since $Tasks'$ already insists that $INITIALTASK$
must remain in $systasks'$);
the task is removed from the set of system tasks, without disturbing the other tasks.

Of course we know there is a parent/child relationship between tasks which the system knows and maintains.
We don't think we need to know about that (except at create time) so we don't model
it\footnote{If we need this it will become clear later when we cannot express a constraint,
or cannot describe a change of state correctly.}.

%=============================================================================
\section{Control group hierarchies}

Although it appears not possible to have a control group hierarchy without an attached subsystem
(see section~\ref{sec:experiments}) we find it easier to consider hierarchies in isolation 
first\footnote{This may reflect the behaviour of the re-architected \emph{cgroups} function currently being developed.}.

We combine the named control groups and system tasks and say how they should be related.
At the same time we describe a function $cgroup$ which maps each task to a control group in the collection.

We are defining a \emph{hierarchy} of control groups:

\begin{schema}{CGHierarchy}
Tasks \\
NamedCGroups
\also
cgroup : TASK \ffun CGPath
\where
tasks \circ cg \partition systasks
\also
\dom cgroup = systasks \\
\forall t : systasks @ t \in tasks ( cg (cgroup ~ t))
\end{schema}
Each task of the system is in precisely one control group, or, as expressed here,
the control group tasks \emph{partition} the system tasks;
\emph{and} there is a function ($cgroup$) which maps each system task to the (full) name
($CGPath$) of the control group in which it resides.

We note that the existence of the function $cgroup$ is guaranteed by the partition requirement
(on $tasks \circ cg$) that accompanies it.
The function $cgroup$ is `derived state', and these assertions impose no extra constraints upon a hierarchy.
In fact, the existence of $cgroup$ is \emph{equivalent} to the partition constraint.

It is legitimate to ask how a $CGHierarchy$ is initialised.
We describe this next along with other operations on a hierarchy.


%----------------------------------------------------------------------------------------------------
\subsection{Hierarchy operations}

It is natural to consider state changes that might `happen' to hierarchies.
We will try to understand how a hierarchy is initialised, how new tasks enter or leave a hierarchy,
and how tasks are moved between control groups in a hierarchy.
Then we can consider how a new control group of a hierarchy is created or destroyed.

Describing each of these operations precisely challenges our state descriptions and constraints---which helps us
to believe that they capture exactly what we want to say.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}

We first consider initialisation of a hierarchy. This is a sort of degenerate operation, as is common in Z specifications.

\begin{schema}{InitCGHierarchy}
CGHierarchy' \\
systasks? : \finset TASK
\where
systasks' = systasks? \\
\exists CGroup' @ \\
( ~~~ cg' = \{ ~ ROOTCGROUPNAME \mapsto \theta CGroup' ~\} \\
\land taskset' = systasks' ~~)
\end{schema}
All existing system tasks are placed in the initial $CGroup$,
with the special root name.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{A single task operation skeleton}

Since $Tasks$ is part of our $CGHierarchy$ state, it is natural to want to use our description of system task operations $CreateTask$
and $DestroyTask$ when describing the (extra) effects upon a hierarchy. The create and destroy operation on
$Tasks$ can be elaborated to explain what happens on the extended state.
In general this is called ``promotion'' and has well-trodden precedents in Z. Our usage here is more of an extension.

We first say what all of these extensions have in common (expressed as a ``promotion'' schema),
which in our case says that fundamental task operations only affect a \emph{single task} in the hierarchy, while
everything else remains fixed.

The $SingleTaskOp$ explains what remains fixed when performing a system task operation in a hierarchy.
It is a skeleton operation schema which we can adapt to particular cases.

\begin{schema}{SingleTaskOp}
task : TASK
\also
\Delta CGHierarchy
\where
systasks' \setminus \{ task \} = systasks \setminus \{ task \}
\also
\{ task \} \ndres cgroup' = \{ task \} \ndres cgroup \\
\dom cg' = \dom cg
\end{schema}
This needs some explaining; the three clauses can be described thus:

Except possibly for $task$, the system tasks are unaffected (neither created nor destroyed).
Except for this same $task$, the association between tasks and their control group path names ($cgroup$) is unaffected.
The control group (directory) structure is likewise unaffected.

Note that, as we noted before, the map $cgroup'$, which is \emph{derived state},
uniquely determines the partition ($tasks \circ cg$) except possibly for
empty control groups. And, \emph{vice versa}, the partition determines the $cgroup$ map.

Simply saying what the new $cgroup$ map should be and that no extra empty control groups arise
(which is the force of $\dom cg = \dom cg'$)
suffices to determine the rest of the new state, partition included.

With this skeleton\footnote{We notice, for the first time, just how symmetric this is:
reverse all the (state) operations (swapping all primed states with their un-primed states---for
example $cgroup'$ and $cgroup$ are exchanged) and we have the same promotion schema.}
we can describe the next operations easily.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Create a new task in a hierarchy}

Here we extend $CreateTask$ as a $SingleTaskOp$eration on a hierarchy.

\begin{schema}{CreateTaskInCG}
CreateTask \\
SingleTaskOp[task! / task]
\where
cgroup' ~ task! = cgroup ~ parent?
\end{schema}
The particular task is renamed to be the \emph{output} task (the one created).
Everything else stays the same (see $SingleTaskOp$) and the new $task!$ goes in the $parent?$'s control group.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Destroy an existing task in a hierarchy}

Deleting a task from the system is even easier to explain:

\begin{schema}{DestroyTaskInCG}
DestroyTask \\
SingleTaskOp[task? / task]
\end{schema}
The particular task is renamed to be the \emph{input} task (the one to be deleted).
Everything else stays the same (see $SingleTaskOp$).
No more needs to be said, since after $DestroyTask$ removes $task?$ from $systasks'$,
everything else is `healed' by the constraints in the promotion.

We are heartened by this: $SingleTaskOp$ captures exactly what we mean by a `task-local' change,
and is sufficient to precisely describe the effects on the $CGHierarchy$ when such changes occur, excepting only
when there is
a hierarchy-specific piece of information to supply.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Move a task from one control group to another}

Within a hierarchy we want to explain what happens if we move a task from one control group to another.
The system tasks are not changed by this, and we need to preserve the partitioning nature of the hierarchy.
We need to supply the task which we are moving ($task?$),
and the (full name of the) control group we are moving it to ($dest?$).
We do not need to supply the control group it `moves from', because the hierarchy state has that information already.

This, it turns out, is another ``single task operation'', so we can use $SingleTaskOp$ again to help to explain it.

\begin{schema}{MoveCGroupTask}
dest? : CGPath
\also
SingleTaskOp[task? / task] \\
\Xi Tasks
\where
task? \in systasks \\
dest? \in \dom cg
\also
cgroup' ~ task?  = dest?
\end{schema}
The constraints on the inputs are that the $task?$ exists already and
the path ($dest?$) is the name of a known control group (of this hierarchy).
The new map $cgroup'$ must map $task?$ to the control group with path name $dest?$.

Amazingly, this is all we need to say. The last line implies that $task? \in \dom cgroup'$ and therefore
$tasks? \in systasks'$ too (from $CGHierarchy'$).

$\Xi Tasks$ ensures that $task?$ must also be in $systasks$ before we start, so `the task exists already' is implied by the last line, although we prefer to be explicit about it.

The $SingleTaskOp$ constraints fix everything else for us.

It is instructive to consider what this operation specification implies if $dest? = cgroup ~ task?$, or in other words, if we
attempt to move a task to the control group it is already in. It should be clear that nothing changes in this case.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Create a new $CGroup$ in a hierarchy}

How does a new control group arise (in a hierarchy)?
Clearly we need to name it, and it must have an initial state, but there are also things to do with the
hierarchy that have to be true, and we mustn't disturb the task structure of the system when
creating a new control group, either:

\begin{schema}{CreateCGroup}
path? : CGPath
\also
\Delta CGHierarchy \\
\Xi Tasks
\where
path? \notin \dom cg \\
path? \neq ROOTCGROUPNAME \\
cg' = cg \cup \{ path? \mapsto EmptyCGroup \} \\
cgroup' = cgroup
\end{schema}
The control group path name is not an existing path (it's not in the old state); it cannot be the root; the new path must point to the empty control group, and the path must `fit' into the $cg$ map (see below); the task partition is unaffected.

What does it mean for the path to `fit'? It means that all its prefixes are in $\dom cg$ already. Equivalently, its immediate parent (the `front' of the sequence) is there.
The constraint which says `$path?$ is not the root', is strictly redundant (it can be derived from the other constraints).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Delete a $CGroup$ from a hierarchy}

When a control group is deleted, what happens to its tasks or its children (in the hierarchy)?
This is explained by saying that you can only destroy control groups that don't have tasks or children.
Here is how this can be formalised:

\begin{schema}{DestroyCGroup}
path? : CGPath
\also
\Delta CGHierarchy \\
\Xi Tasks
\where
path? \notin \dom cg' \\
path? \neq ROOTCGROUPNAME \\
cg = cg' \cup \{ path? \mapsto EmptyCGroup \} \\
cgroup' = cgroup
\end{schema}
The constraints say: this is not a new path (it's not in the new state); it cannot be the root;
the path identifies the empty control group (in the old state); the task partition is unaffected.

Notice that the path \emph{used to} `fit' in $cg$, and if removing it leaves the $cg'$ structured correctly,
this means it cannot have had any children beforehand.

The constraint which says `$path?$ is not the root', is \emph{also} redundant.
It is harder to see why in this case, but removing the root would produce a $CGHierarchy'$ with an empty map $cg'$.
The constraints on $CGHierarchy'$ (in particular from the $NamedCGroups'$ schema) prohibit this.

The constraints for $Create$... and $Destroy$... are deliberately symmetric.
Doing it this way helped us to (write and) understand them.

%=============================================================================
\section{Subsystems}

A $Subsystem$ is a collection of resource sets named by $CGPath$ names. We will eventually marry
this with a $GCHierarchy$, but we consider it in isolation first.
\begin{schema}{Subsystem}
res : CGPath \ffun ResourceSet
\also
pinned : \finset CGPath
\where
pinned = \dom(res \nrres \{ \emptyset \})
\end{schema}
Resource sets ``named by control group path names'' are represented by the map $res$;
$pinned$ is derived state (completely determined by $res$) and consists of the control group path
names which refer to non-empty resource sets\footnote{$\dom(res \nrres \{ \emptyset \})$
is a technical jewel, meaning the domain
of the relation which is that subset of $res$ consisting of pairs that do not relate names to the empty
resource set.}.

%----------------------------------------------------------------------------------------------------
\subsection{Subsystem operations}
We consider initialisation
and basic resource update operations, which we lift from the $Resources$ operations we had before.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}
We cannot say everything about the initial subsystem (until the $CGHierarchy$ is available), but we might try to
say:
\begin{zed}
%% \exists Subsystem' @
pinned' = \emptyset
\end{zed}
which doesn't tie down the domain of $res$, but at least says that there are no resources in its range.

\emph{This is a mistake.}
There is \emph{no} guarantee that a subsystem initially uses \emph{no} resources---in fact it is
extremely likely that \emph{some} resources will be used by the tasks of the system which, remember, appear in the
root of a hierarchy when
it is created. So we should not say anything about an \emph{initial} $Subsystem$.
For completeness we will define the name though:
\begin{zed}
InitSubsystem \defs Subsystem'
\end{zed}
letting it `flap' completely (except for the usual subsystem state constraints, of course).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Lifting the resource set operations}
We want to add and remove resources from a particular resource set. In general we can say
how we lift an operation on resource sets to subsystems:

\begin{schema}{SubsystemResourcesOp}
cgp? : CGPath
\also
\Delta Subsystem \\
\Delta Resources
\where
cgp? \in \dom res \\
\{ cgp? \} \ndres res = \{ cgp? \} \ndres res' \\
res ~ cgp? = rs \\
res' ~ cgp? = rs'
\end{schema}
There is an input path name ($cgp?$) which must be a known name of the subsystem;
the resource sets (other than the one named $cgp?$) are not changed;
the resource set named $cgp?$ is changed in precisely the way that the $Resources$ operation changes
its resource set ($rs$ goes to $rs'$).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Add and remove resources}
When we combine $SubsystemResourcesOp$ with operations on $Resources$
(which include the signature $\Delta Resources$)
we get a lifted operation definition on $Subsystem$ except for the $\Delta Resources$ signature,
which we can then hide.

\begin{zed}
AddSSResources \defs \\
\t2 \exists \Delta Resources @ ( AddResources \land SubsystemResourcesOp )
\also
RemoveSSResources \defs \\
\t2 \exists \Delta Resources @ ( RemoveResources \land SubsystemResourcesOp )
\end{zed}
The $\exists \Delta Resources @$ prefix is just a clumsy way of hiding the $Resources$ and $Resources'$ states
which we only needed to expose to explain the lifting, and should not be exposed on the
subsystem operation.

Are these \emph{really} operations on $Subsystem$?

We can demonstrate that they are by deriving the ``signature'' of, for example, $AddSSResources$,
and it works out as\footnote{Not really,
for we have preserved some constraints in the declarations to make it easier to relate to our other operations.}:

\begin{schema*}
rs? : ResourceSet\\
cgp? : CGPath\\
\Delta Subsystem
\end{schema*}
which is clearly an operation with inputs $rs?$, a set of resources, and $cgp?$, a path name, as we would expect.

%=============================================================================
\section{Attached subsystems}
$Subsystem$s are pretty an\ae{}mic because they are not yet `attached' to a hierarchy. This is what we describe next.

\begin{schema}{AttachedSubsystem}
Subsystem \\
CGHierarchy
\where
\dom res = \dom cg
\end{schema}
The control group paths that the subsystem tracks are precisely the ones in
the attached hierarchy.

%----------------------------------------------------------------------------------------------------
\subsection{Attached subsystem operations}
The operations on $CGHierarchy$ and those on $Subsystem$ can now be lifted to $AttachedSubsystem$
by similar lifting mechanisms we used before. The constraints (aka preconditions) imposed
by $CGHierarchy$ and $Subsystem$ operations combine via the
$AttachedSubsystem$ constraint, to enable us to derive many (but not all) of the preconditions of the lifted operations.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}

The initially attached subsystem ought to be a simple combination of initial subsystem and initial hierarchy; and it is:

\begin{zed}
InitAttachedSubsystem \defs \\
\t1 AttachedSubsystem' \land InitSubsystem \land InitCGHierarchy
\end{zed}
Notice that the resources used by the initial (root) control group might be anything---we had to allow this when
explaining $InitSubsystem$.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Operations lifted from $CGHierarchy$}

In $CGHierarchy$ operations we created a new task, destroyed an existing task, moved a task and created and destroyed
a control group.  All of these occur when a subsystem is attached to the hierarchy, and we can explain the \emph{extra}
constraints easily enough.

In each case the hierarchy changes are already stipulated, we only have to say what happens to the subsystem that is
tracking it.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Create a task:}
We have to explain what parts of the subsystem may change when a new task is created:

\begin{schema}{CreateTaskInAttachedCGH}
\Delta AttachedSubsystem \\
CreateTaskInCG
\where
\LET cgp == cgroup' ~ task! @ \\
\t1 \{cgp\} \ndres res = \{cgp\} \ndres res' \land \\
\t1 res ~ cgp \subseteq res' ~ cgp
\end{schema}
Here we've introduced a local shorthand $cgp$ for $cgroup' ~ task!$, the name of the control group which contains
the new task ($task!$); the resource-set map, $res$, remains the same on all control groups except this one;
on this one the resource set usage may increase (but it cannot decrease).

This is intentionally non-deterministic because we cannot say what resources a new task might require or
what its parent might require. In general, then, we might add resources into the control group.

Note that it is possible for the $pinned$ set to increase but only by the addition of the single control group
named $cgp$.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Destroy a task:}
We have to explain what parts of the subsystem may change when a task is destroyed:

\begin{schema}{DestroyTaskInAttachedCGH}
\Delta AttachedSubsystem \\
DestroyTaskInCG
\where
\LET cgp == cgroup ~ task? @ \\
\t1 \{cgp\} \ndres res = \{cgp\} \ndres res' \land \\
\t1 res' ~ cgp \subseteq res ~ cgp
\end{schema}
Shorthand again;  the resource-set map, $res$, remains the same on all control groups except this one;
on this one the resource set usage may \emph{decrease} (but it cannot increase).

Here the $pinned$ set might reduce by one control group, but only one.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Move a task:}
We have to explain what parts of the subsystem may change when a task is moved from one control group to another.

\begin{schema}{MoveTaskInAttachedCGH}
\Delta AttachedSubsystem \\
MoveCGroupTask
\where
\LET src == cgroup ~ task? @ \\
\t1 \{src, dest?\} \ndres res = \{src, dest?\} \ndres res' \land \\
\t1 res' ~ src \subseteq res ~ src \land \\
\t1 res ~ dest? \subseteq res' ~ dest?
\end{schema}
This time we introduce local shorthand for the source control group ($src$);
the $res$ map remains unchanged on all control groups except possibly for the source and destination control groups;
the source control group resources might decrease;
the destination control group resources might increase.

We are tempted to say that the resources transfer from one control group to the other; but we cannot say this.
In general the transfer may involve extra resources, or it may reduce the resources used. Particular
subsystems might be able to say more about this.

Again it is instructive to consider what happens if the source and destination are the same control group. The specification implies that this is a no-op: the resources used are unchanging. It remains to be seen if this is the case,
but we would be surprised if it wasn't.  It is nice to see this falling out of a general description.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Create a control group:}
We have to explain what parts of the subsystem may change when a new control group is created:

\begin{schema}{CreateCGroupInAttachedCGH}
\Delta AttachedSubsystem \\
CreateCGroup
\where
res' ~ path? = \emptyset \\
res = \{path?\} \ndres res'
\end{schema}
The new control group uses no resources (and has no tasks you may recall from $CreateCGroup$); the resources
for all the other control groups remain the same. Notice how the $\Delta AttachedSubsystem$ constraints save us
from having to say stuff like `no other control groups magically appear'.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Destroy a control group:}
We have to explain what parts of the subsystem may change when a control group is destroyed:

\begin{schema}{DestroyCGroupInAttachedCGH}
\Delta AttachedSubsystem \\
DestroyCGroup
\where
res ~ path? = \emptyset \\
res' = \{path?\} \ndres res
\end{schema}
The control group being destroyed \emph{must not be using any resources};
the resources for all the other control groups remain
the same.

Not using any resources tallies with the $CGHierarchy$ operation constraint that it must have no tasks when it is
destroyed, although not having tasks doesn't imply it is not using resources).

We also get the parent-child restrictions for free (ultimately from $NamedCGroups$).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Operations lifted from $Subsystem$}

Adding or removing resources from a particular control group has no effect on the structure or the tasks
in a hierarchy.

We can therefore lift the $Add$ and $Remove$ resources operations directly as follows:

\begin{zed}
AddResourcesInAttachedSubsystem \defs \\
\t1 AddSSResources \land \Delta AttachedSubsystem \land \Xi CGHierarchy
\also
RemoveResourcesInAttachedSubsystem \defs \\
\t1 RemoveSSResources \land \Delta AttachedSubsystem \land \Xi CGHierarchy
\end{zed}
where $\Xi CGHierarchy$ documents that the hierarchy remains unchanged.

%=============================================================================
\section{Many subsystems}

The aim of this section is to move away from considering just one subsystem and its affect upon
a control group hierarchy, to the more general case where two or more subsystems are attached
to the same hierarchy.

We model this as a collection of $AttachedSubsystem$s, where the hierarchies are identical.
A function which extracts just the control group hierarchy from an $AttachedSubsystem$ is then useful:
\begin{zed}
cgHierarchy == (\lambda AttachedSubsystem @ \theta CGHierarchy)
\end{zed}
and we can use this  function to ensure that the hierarchies spoken of in the $AttachedSubsystem$
collection are all the same.

Multiple subsystems attached to the same hierarchy consists of a set of subsystem names, a map from this set
to $AttachedSubsystem$s, and the control group hierarchy which is common to them all.
\begin{schema}{MultiSubsystems}
subNames : \finset_1 SSNAME \\
subs : SSNAME \ffun AttachedSubsystem \\
commonCGH : CGHierarchy
\where
subNames = \dom subs \\
\forall sn : subNames @ \\
    \t1 cgHierarchy(subs ~ sn) = commonCGH
\end{schema}
The domain of the map is exactly the set of subsystem names, and every named subsystem's
control group hierarchy is identical to the top-level one.

There are two points to be made: the set of subsystem names ($subNames$) is \emph{non-empty}, ensuring at least
one $AttachedSubsystem$ exists; and the common hierarchy is really only there to tie them together, but
we will see advantages to giving it a separate, subsystem-independent name later.

%----------------------------------------------------------------------------------------------------
\subsection{Many subsystems operations}

Previously we have used $\Delta$ to indicate the before and after states of a schema, but in this case we want to
impose an additional constraint on all of our operations. After a $MultiSubsystem$ is created we want to insist that
the set of subsystems remains fixed. This reflects reality where the act of \texttt{mount}ing the subsystems creates the
hierarchy at the same time, and there is no API for partially \emph{un}mounting a subsystem, or adding one to an existing mount point.

We will define what is allowed to change for every $MultiSubsystems$ operation:

\begin{schema}{MultiSubsystemsChange}
\Delta MultiSubsystems
\where
subNames' = subNames
\end{schema}
Every operation leaves the named subsystems unchanged.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}

Since the $subNames$ cannot change, when are they initialised? When the first $MultiSubsystems$ state is created:

\begin{schema}{InitMultiSubsystems}
subNames? : \finset_1 SSNAME \\
systasks? : \finset TASK \\
MultiSubsystems' \\
\where
subNames' = subNames? \\
\forall sn : subNames? @ \\
\t1 \exists AttachedSubsystem' | subs' ~ sn = \theta AttachedSubsystem' @ \\
    \t2 InitAttachedSubsystem
\end{schema}
We need to supply the subsystems names (at least one of them), and the system tasks currently
extant, and the attached subsystems are each
initialised appropriately. The $MultiSubsystems'$ constraints imply that the hierarchies match.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Lifting attached subsystem operations}

The operations to be lifted are: create,  destroy and move a task;
create and destroy a control group; and add and remove resources, which should act on an
identified subsystem.

These groups of operations are lifted in two different ways, reflecting the fact that four of them
affect \emph{all} the subsystems, and two of them (the resource ones) affect only \emph{one} subsystem.

The first way is where all the subsystems change together. We describe what one among many changes might look like:
\begin{schema}{OneSubsystemChange}
sn : SSNAME \\
MultiSubsystemsChange \\
\Delta AttachedSubsystem
\where
subs ~ sn = \theta AttachedSubsystem \\
subs' ~ sn = \theta AttachedSubsystem'
\end{schema}
crucially, we do not insist here that all the other subsystems remain fixed (which is what a `point operation' promotion would do).

The second way is when we wish to insist that \emph{only} one subsystem is changed (normally the subsystem name is input).

We augment
$OneSubsystemChange$ to say this:
\begin{schema}{OnlySubsystemChange}
OneSubsystemChange[ sn? / sn ] \\
\where
\{ sn? \} \ndres subs = \{ sn? \} \ndres subs' \\
\end{schema}
which adds the further restriction that all the other subsystems remain the same in this case.

We use these two types of `lifting' for our lifted operations.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Create a task:}

When a new task is created all attached subsystems change simultaneously. We expose the output $task!$ and the input $parent?$ as usual:

\begin{schema}{CreateTaskInMultiSs}
MultiSubsystemsChange \\
parent?, task! : TASK
\where
\forall sn : subNames @ \\
\t1 \exists \Delta AttachedSubsystem | OneSubsystemChange @ \\
    \t2 CreateTaskInAttachedCGH
\end{schema}
Each attached subsystem in $subs$ changes as described in $CreateTaskInAttachedCGH$.

Notice that all the inputs and outputs to the individual operations are identical and that the hierarchies (all being identical)
can only change in the same way---however, the resources may change in different ways for the different subsystems as permitted by
$CreateTaskInAttachedCGH$.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Destroy a task:}

When a task is destroyed all attached subsystems change simultaneously. We expose the input $task?$ as usual:
\begin{schema}{DestroyTaskInMultiSs}
MultiSubsystemsChange \\
task? : TASK
\where
\forall sn : subNames @ \\
\t1 \exists \Delta AttachedSubsystem | OneSubsystemChange @ \\
    \t2 DestroyTaskInAttachedCGH
\end{schema}
Each attached subsystem changes as described in $DestroyTaskInAttachedCGH$.

Here the resources are depleted in each subsystem, but the resources involved in each subsystem need not be the same.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Move a task:}

Moving a task to a control group operates in a similar way.  We expose the inputs dest? and task? as before:
\begin{schema}{MoveTaskInMultiSs}
MultiSubsystemsChange \\
dest? : CGPath \\
task? : TASK
\where
\forall sn : subNames @ \\
\t1 \exists \Delta AttachedSubsystem | OneSubsystemChange @ \\
    \t2 MoveTaskInAttachedCGH
\end{schema}
Each attached subsystem manages the move in the same way, but may involve quite different resources in each case.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Create a control group:}

A new control group is created in each attached subsystem in the same way:

\begin{schema}{CreateCGroupInMultiSs}
MultiSubsystemsChange \\
path? : CGPath
\where
\forall sn : subNames @ \\
\t1 \exists \Delta AttachedSubsystem | OneSubsystemChange @ \\
    \t2 CreateCGroupInAttachedCGH
\end{schema}
Each attached subsystem creates the new control group ($path?$) with no resources.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Destroy a control group:}

A control group is removed from each attached subsystem:

\begin{schema}{DestroyCGroupInMultiSs}
MultiSubsystemsChange \\
path? : CGPath
\where
\forall sn : subNames @ \\
\t1 \exists \Delta AttachedSubsystem | OneSubsystemChange @ \\
    \t2 DestroyCGroupInAttachedCGH
\end{schema}
Each attached subsystem destroys a control group in the same way.

Notice that \emph{every} subsystem must satisfy the constraints for this operation to apply.
Any resource for this control group \emph{in any subsystem} will prevent this.

% .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
\subparagraph{Add and remove resources:}

Adding and removing resources applies to \emph{only} one subsystem.

\begin{zed}
AddResourcesInMultiSs \defs  \exists \Delta AttachedSubsystem @ \\
    \t1 AddResourcesInAttachedSubsystem \land OnlySubsystemChange
\also
RemoveResourcesInMultiSs \defs  \exists \Delta AttachedSubsystem @ \\
    \t1 RemoveResourcesInAttachedSubsystem \land OnlySubsystemChange
\end{zed}
Here we use standard pointwise lifting.

The subsystem name input ($sn?$) appears in $OnlySubsystemChange$
and the other inputs appear in the ...$ResourcesInAttachedSubsystem$ operations.

%=============================================================================
\section{Relating the model to \texttt{cgroups} function}

Each operation on the $MuiltiSubsystems$ state is related to a kernel command or action. 

%----------------------------------------------------------------------------------------------------
\subsection{$InitMultiSubsystems$}

The signature of the initialisation in the model is:

\begin{schema*}
    systasks?: \finset TASK \\
    subNames? : \finset SSNAME \\
\also
  MultiSubsystems'
\end{schema*}
The \texttt{mount} command creates a $MultiSubsystems$ state, that is, it names and attaches subsystems to a 
(newly created) hierarchy.

\begin{verbatim}
    mount -t cgroup <mountName> -o<subNames> <h-path>
\end{verbatim}
The \texttt{<mountName>} is ignored (except perhaps for messages), 
the option (following \texttt{-o}) is a non-empty list of subsystem names
($subNames?$), and \texttt{<h-path>} is a location in a filesystem
where the state of the multiple subsystems and the hierarchy are surfaced (see further API).

The input $systasks?$ is the set of extant tasks (processes) in the system when the subsystems and hierarchy
are created and is an implicit parameter to the \texttt{mount}.

Directories in the control group filesystem at \texttt{<h-path>} correspond to control groups, 
and each subsystem contributes
(pseudo) files to those directories.

Notice that if any filesystem is mounted on an existing mount point (\texttt{<h-path>} above) then the first 
\texttt{mount} is overwritten.
A consequence of this is that subsystems may not be detached or attached to hierarchies that are already mounted.

%----------------------------------------------------------------------------------------------------
\subsection{$CreateTaskInMultiSs$}

The signature of the task creation operation is:
\begin{schema*}
    parent?: TASK \\
    task!: TASK \\
\also
    \Delta MultiSubsystems
\end{schema*}
A task created by any process automatically causes this operation to occur for all attached subsystems.

The implicit input $parent?$ is the new task's parent task, and the output $task!$ is the task which is created.

As the subsystem state changes so the
filesystem rooted in \texttt{<h-path>} reflects these updates for the relevant control groups.

%----------------------------------------------------------------------------------------------------
\subsection{$DestroyTaskInMultiSs$}

Similarly, the signature of the task destruction operation is:
\begin{schema*}
    task?: TASK
\also 
    \Delta MultiSubsystems
\end{schema*}
When a task dies and the kernel decides it has been destroyed then this operation occurs.

The input $task?$ is the task which is about to die.

As the subsystem state changes so the
filesystem rooted in \texttt{<h-path>} reflects these updates for the relevant control groups.


%----------------------------------------------------------------------------------------------------
\subsection{$MoveTaskInMultiSs$}

Moving a task from one control group to another has this signature:
\begin{schema*}
    task?: TASK \\
    dest?: CGPath
\also 
    \Delta MultiSubsystems
\end{schema*}
This is an operation explicitly initiated by a control group action, for example when
the process id (\texttt{pid}) referring to the task ($task?$) is written into a 
(pseudo) file in the \texttt{cgroup} filesystem 
(rooted at \texttt{<h-path>}),
in a directory corresponding to the destination \texttt{cgroup} (path $dest?$).

For example:
\begin{verbatim}
    echo 1234 >/h-path/dest/cg1/tasks
\end{verbatim}
will move the task with process id \texttt{1234} from whatever control group it is currently in to 
the control group \texttt{dest/cg1}.

Whether or not \emph{resources} move with the task is determined by subsystem settings, and is not
prohibited nor mandated by our model operation.

%----------------------------------------------------------------------------------------------------
\subsection{$CreateCGroupInMultiSs$}

Creating a new control group in a hierarchy has this signature:
\begin{schema*}
    path?: CGPath
\also 
    \Delta MultiSubsystems
\end{schema*}
A control group is created when a new directory is created (for example with \texttt{mkdir}) 
in the \texttt{cgroup} filesystem.

The input $path?$ is the relative path of the directory from the \texttt{<h-path>} root.

Each subsystem automatically contributes
(pseudo) files to the new directory. There are initially \emph{no} tasks associated with the new control group.

%----------------------------------------------------------------------------------------------------
\subsection{$DestroyCGroupInMultiSs$}

Destroying a control group has the same signature as creating one:
\begin{schema*}
    path?: CGPath
\also 
    \Delta MultiSubsystems
\end{schema*}
A control group is deleted when its directory is removed (with \texttt{rmdir}, or equivalent) from the 
\texttt{cgroup} filesystem.

Before this will succeed (as the model describes), there must be no tasks and no resources 
associated with that control group,
and there must be no subdirectories in the control group directory.

A consequence of these restrictions means that the root control group can never be deleted by this operation.

%----------------------------------------------------------------------------------------------------
\subsection{$Add$ and $Remove$ $ResourcesInMultiSs$}

The model signatures for adding and removing resources managed by a subsystem are the same:

\begin{schema*}
    rs?: ResourceSet \\
    cgp?: CGPath \\
    sn?: SSNAME \\
\also
    \Delta MultiSubsystems
\end{schema*}
These are the set of resources to be added or removed ($rs?$), the control group where these resource changes are to take place ($cgp?$), and the (name of the) subsystem which is managing these resources ($sn?$).

These operations describe only the most basic features of subsystems' resource management.
They are limited to one subsystem's resources in one control group.

They are instigated by a subsystem as a result of some system state change rather 
than by an explicit command or action by a process.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage

\appendix

%=============================================================================
%   Z   N O T A T I O N
%=============================================================================
\input{../z/z-notation.tex}


%=============================================================================
%   S O U R C E S
%=============================================================================
\section{Sources}
\label{sec:sources}

As input to this work we accessed the following sources of information:
\begin{description}
\item[Kernel specs] descriptions of control groups in the Kernel literature\cite{linuxgroups};
\item[Kernel code] the Linux Kernel\cite{linuxkernel};
\item[experiments] tests run against the \texttt{cgroups} kernel code (see appendix \ref{sec:notes});
\item[RedHat article] which provides ``invariants'' of the filesystem\cite{rharticle};
\item[Linux kernel mailing list] for informative and timely Q and A\cite{noop}.
\end{description}

%----------------------------------------------------------------------------------------------------
\subsection{The Linux specification\cite{linuxgroups}}

Here is the first section of the Linux \texttt{cgroups} specification\cite{linuxgroups}:

{\scriptsize \begin{verbatim}
1.1 What are cgroups ?
----------------------

Control Groups provide a mechanism for aggregating/partitioning sets
of tasks, and all their future children, into hierarchical groups with
specialized behaviour.

Definitions:

A *cgroup* associates a set of tasks with a set of parameters for one
or more subsystems.

A *subsystem* is a module that makes use of the task grouping
facilities provided by cgroups to treat groups of tasks in
particular ways. A subsystem is typically a "resource controller" that
schedules a resource or applies per-cgroup limits, but it may be
anything that wants to act on a group of processes, e.g. a
virtualization subsystem.

A *hierarchy* is a set of cgroups arranged in a tree, such that
every task in the system is in exactly one of the cgroups in the
hierarchy, and a set of subsystems; each subsystem has system-specific
state attached to each cgroup in the hierarchy.  Each hierarchy has
an instance of the cgroup virtual filesystem associated with it.

At any one time there may be multiple active hierarchies of task
cgroups. Each hierarchy is a partition of all tasks in the system.

User-level code may create and destroy cgroups by name in an
instance of the cgroup virtual file system, specify and query to
which cgroup a task is assigned, and list the task PIDs assigned to
a cgroup. Those creations and assignments only affect the hierarchy
associated with that instance of the cgroup file system.

On their own, the only use for cgroups is for simple job
tracking. The intention is that other subsystems hook into the
generic cgroup support to provide new attributes for cgroups, such
as accounting/limiting the resources which processes in a cgroup can
access. For example, cpusets (see Documentation/cgroups/cpusets.txt)
allow you to associate a set of CPUs and a set of memory nodes with
the tasks in each cgroup.
\end{verbatim}}

Although this reads reasonably well (and by comparison to its peers it is a pretty good document) it commits some
specification sins\footnote{We don't mean this as an insult: without documents like these we couldn't do our work;
it is no worse---and in many ways better---than many such.} (see Meyer\cite{7sins}).
For example, it is ambiguous concerning the number of and relationship between hierarchies; it
doesn't explain what the initial state of a control group is; it talks about tasks and processes as though they were the same without comment (we think they are the same);
the rules about the relationship between tasks and control groups sound contradictory; and so on.


%=============================================================================
%   N O  T E S
%=============================================================================
\section{Notes and experiments}
\label{sec:notes}

We gather here some observations, experiments and discussions which have informed our research.

%----------------------------------------------------------------------------------------------------
\subsection{Mailing lists discussions}

It does not seem possible to define a \texttt{cgroup} hierarchy with no subsystems attached to it.
See the mailing list discussion\cite{noop}.

%----------------------------------------------------------------------------------------------------
\subsection{Experiments}
\label{sec:experiments}
We performed some simple experiments on a (virtual, and hence infinitely refreshable) Linux machine.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Multiple subsystems}

Attaching multiple subsystems to a single hierarchy:
{\scriptsize \begin{verbatim}
# cd /tmp/warden/cgroup
# mkdir test
# mount -t cgroup -o 'cpuset,blkio' none /tmp/warden/cgroup/test
# cd test
# mkdir parent
# cd parent
# echo 0 > cpuset.mems
# echo 0 > cpuset.cpus
# echo $$ > tasks
# cat tasks
1840
2014
# cat /proc/1840/cgroup
13:blkio,cpuset:/parent
4:memory:/parent/child
3:devices:/
2:cpuacct:/
1:cpu:/
# cat /proc/cgroups
#subsys_name	hierarchy	num_cgroups	enabled
cpuset	13	2	1
cpu	1	1	1
cpuacct	2	1	1
memory	4	3	1
devices	3	1	1
freezer	0	1	1
blkio	13	2	1
perf_event	0	1	1
# cat /proc/mounts
...
none /tmp/warden/cgroup tmpfs rw,relatime 0 0
none /tmp/warden/cgroup/cpu cgroup rw,relatime,cpu 0 0
none /tmp/warden/cgroup/cpuacct cgroup rw,relatime,cpuacct 0 0
none /tmp/warden/cgroup/devices cgroup rw,relatime,devices 0 0
none /tmp/warden/cgroup/memory cgroup rw,relatime,memory 0 0
none /tmp/warden/cgroup/test cgroup rw,relatime,blkio,cpuset 0 0
\end{verbatim}}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Multiple hierarchies}

Attaching a single subsystem to multiple hierarchies:
{\scriptsize \begin{verbatim}
$ pwd
/home/vagrant
$ mkdir mem1
$ mkdir mem2
$ sudo su
# mount -t cgroup -o memory none /home/vagrant/mem1
# mount -t cgroup -o memory none /home/vagrant/mem2
# cd mem1
# mkdir inst1
# ls inst1
cgroup.clone_children  memory.failcnt ...
# ls ../mem2
cgroup.clone_children  inst1 memory.limit_in_bytes ...
# cd inst1
# echo 1000000 > memory.limit_in_bytes
# cat memory.limit_in_bytes
1003520
# cat ../../mem2/inst1/memory.limit_in_bytes
1003520
# echo $$ > tasks
# cat tasks
1365
1409
# cat ../../mem2/inst1/tasks
1365
1411
\end{verbatim}}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Overlapping hierarchies}

Attaching a new subsystem to one of the hierarchies attached to an existing subsystem (this follows on from the previous experiment):
{\scriptsize \begin{verbatim}
# mount -t cgroup -o cpuset none /home/vagrant/mem1
# ls /home/vagrant/mem1
cpuset.cpus ... // No memory.* files!
# ls /home/vagrant/mem2
cgroup.clone_children  inst1 memory.limit_in_bytes ...
\end{verbatim}}



%=============================================================================
%   B I B L I O G R A P H Y
%=============================================================================
\newpage
\begin{flushleft}
\begin{thebibliography}{99}
\label{sec:references}
% `99' is a picture of the generated numeric references -- they are two digits in this bibliography
% If we had a hundred or more we would have used 999, or whatever.

%%  Example bibliography entry:
%\bibitem{knuth76}                                                        % citation callout, e.g.: \cite{knuth76}
%  Donald E. Knuth,                                                        % author
%  \emph{The computer as Master Mind}.                    % title
%  J. Recreational Mathematics, Vol.~9(1), 1976-1977. % publisher, or journal, volume and date

\bibitem{warden}
  Various authors,
  \emph{Warden github repository},
  \texttt{https://github.com/cloudfoundry/warden}.

\bibitem{garden}
  Various authors,
  \emph{Garden github repository},
  \texttt{https://github.com/pivotal-cf-experimental/garden}.

% API abstracting the cgroup filesystem
% See http://manpages.ubuntu.com/manpages/lucid/man5/cgconfig.conf.5.html for configuration containing useful insights
\bibitem{libcgroup}
  Various authors
  \emph{libcgroup},
  {\small \texttt{http://libcg.sourceforge.net/html/index.html}}.

\bibitem{linuxgroups}
  Paul Menage, Paul Jackson and Christoph Lameter,
  \emph{CGROUPS},
  {\small \texttt{https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt}}, 2004-2006.

\bibitem{linuxkernel}
  Linus Torvalds, \emph{et al},
  \emph{Linux kernel source tree},
  {\small \texttt{https://github.com/torvalds/linux}}.

\bibitem{memory}
  Various authors,
  \emph{Memory Resource Controller},
  {\small \texttt{https://www.kernel.org/doc/Documentation/cgroups/memory.txt}}.

\bibitem{noop}
  Kamezawa Hiroyuki, \emph{et al},
  \emph{NOOP cgroup subsystem},
  {\small \texttt{http://thread.gmane.org/gmane.linux.kernel/777763}}.

\bibitem{rharticle}
  Martin Prpi\u{c}, R\"udiger Landmann, and Douglas Silas,
  \emph{Red Hat Enterprise Linux 6.5 GA: Resource Management Guide},
  {\small \texttt{https://access.redhat.com/site/documentation/en-US\slash{}Red\_Hat\_Enterprise\_Linux/6/pdf/Resource\_Management\_Guide\slash{}Red\_Hat\_Enterprise\_Linux-6-Resource\_Management\_Guide-en-US.pdf}}.

\bibitem{7sins}
  Bertrand Meyer,
  \emph{On Formalism In Specifications},
  IEEE Software, Vol.~2(1), 1985.
\end{thebibliography}
\end{flushleft}
\end{document}
