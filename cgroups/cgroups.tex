\documentclass[a4paper,twoside,12pt]{article}
\usepackage{zed-cm}
\usepackage{graphicx}
\usepackage[nottoc,numbib]{tocbibind}
\markboth{Draft}{Version 0.2}
\pagestyle{myheadings}
\begin{document}
\parskip 2 pt
\parindent 10 pt

\def\Slash{\slash\hspace{0pt}}

\title{A Model of Linux Control Groups and Subsystems}

\author{
Glyn Normington\and
Steve Powell
}

\maketitle
% The following three commands ensure the title page is stamped as
% confidential without a page number. Page numbering is started at the
% table of contents.
\thispagestyle{myheadings}
\pagenumbering{roman}
\setcounter{page}{1}

%=============================================================================

This is a working document which serves to record the justifications, deliberations and results\footnote{but 
not, alas, the mistakes} of an attempt to
specify precisely some (or all) of the features of \emph{Linux control groups} and \emph{subsystems} which can support robust and reliable development of \emph{Warden} and related products.

\paragraph{Current ``to-do'' list:}
\begin{itemize}
\item \emph{ops}---describe more operations (e.g. on $CGroupsTasks$); (\textsc{Done})
\item \emph{hierarchy}---describe trees of $CGroup$s; (\textsc{Done})
\item \emph{subsystem}---describe subsystems and attachment to hierarchies; (\textsc{Done} -- almost)
\item \emph{RedHat rule 2}---make rule 2 into a constraint on subsystems+hierarchies;
\item \emph{RedHat rules}---ensure all RedHat rules are represented correctly.
\end{itemize}

% Alt-Cmd-M -- \emph{}
% Alt-Cmd-Z -- \zed{}
% Alt-Cmd-X -- \axdef{}
% Alt-Cmd-S -- \schema{}
% Alt-Shift-Cmd-T -- \texttt{}

% Type checking hacks
\newcommand{\true}{true}
\newcommand{\false}{false}
\renewcommand{\emptyset}{\varnothing}
%=============================================================================

\clearpage
\tableofcontents

\cleardoublepage
\pagenumbering{arabic}

%=============================================================================
\section{Introduction}

In order to implement some features and improvements to \emph{Warden} we intend to sharpen our understanding of Linux control groups and simultaneously document their use.

Linux control groups are part of the basis for the current implementation of Warden as well as of Linux Containers (LXC), Docker, and Google's
\textit{lmctfy} (``let me contain that for you'') project and so are important to the industry as well as to Cloud
Foundry.

In the process we intend to use our improved understanding to benefit:
\begin{itemize}
\item Linux Kernel documentation;
\item Warden \cite{warden} and Garden \cite{garden} development and exploitation; and
\item the wider development audience.
\end{itemize}
In particular, a clearer understanding of Warden/Garden and their basis in Linux control groups will put their development 
on a much firmer footing and enable key abstractions to be introduced which will provide a much-needed, stable structure upon which
functional enhancements and the likely future evolution of Linux control groups can rest.

These are the deliverables we plan:

\begin{itemize}
\item \emph{CGroupSpec}: a precise Z specification for control groups, and (at least) the \texttt{memory} subsystem, states;
\item an improved introduction (for Z0L readers\footnote{\emph{Z0L} refers to people who do not speak Z; Z is their \emph{zero}th language.}) of control groups, etc.;
\item \emph{WardenSpec}: a precise Z specification for a Warden API, using some or all of the \emph{CGroupSpec} state;
\item an english version of the same (for Z0L readers);
\item an implementation framework that maps \emph{WardenSpec} to \emph{CGroupSpec}; and
\item proposals for future development of Warden functionality by reference to these specs.
\end{itemize}
As input to this work we access the following sources of information:
\begin{description}
\item[Kernel specs] the english descriptions of control groups in the Kernel literature \cite{linuxgroups};
\item[Kernel code] the Linux Kernel \cite{linuxkernel};
\item[experiments] tests run against the CGroups kernel code (on a shared VM);
\item[RedHat article] an article about CGroups written by RedHat which provides some invariants of the pseudo-filesystem state \cite{rharticle}.
\item[Linux kernel mailing list] \cite{noop} where we asked questions and got informative and timely answers.
\end{description}

%----------------------------------------------------------------------------------------------------
\subsection{The Linux specification \cite{linuxgroups}}

In order to kick off the discussion (and to show what we're up against) we include the first section of \cite{linuxgroups} here:

{\small \begin{verbatim}
1.1 What are cgroups ?
----------------------

Control Groups provide a mechanism for aggregating/partitioning sets
of tasks, and all their future children, into hierarchical groups with
specialized behaviour.

Definitions:

A *cgroup* associates a set of tasks with a set of parameters for one
or more subsystems.

A *subsystem* is a module that makes use of the task grouping
facilities provided by cgroups to treat groups of tasks in
particular ways. A subsystem is typically a "resource controller" that
schedules a resource or applies per-cgroup limits, but it may be
anything that wants to act on a group of processes, e.g. a
virtualization subsystem.

A *hierarchy* is a set of cgroups arranged in a tree, such that
every task in the system is in exactly one of the cgroups in the
hierarchy, and a set of subsystems; each subsystem has system-specific
state attached to each cgroup in the hierarchy.  Each hierarchy has
an instance of the cgroup virtual filesystem associated with it.

At any one time there may be multiple active hierarchies of task
cgroups. Each hierarchy is a partition of all tasks in the system.

User-level code may create and destroy cgroups by name in an
instance of the cgroup virtual file system, specify and query to
which cgroup a task is assigned, and list the task PIDs assigned to
a cgroup. Those creations and assignments only affect the hierarchy
associated with that instance of the cgroup file system.

On their own, the only use for cgroups is for simple job
tracking. The intention is that other subsystems hook into the
generic cgroup support to provide new attributes for cgroups, such
as accounting/limiting the resources which processes in a cgroup can
access. For example, cpusets (see Documentation/cgroups/cpusets.txt)
allow you to associate a set of CPUs and a set of memory nodes with
the tasks in each cgroup.
\end{verbatim}}
Although this reads reasonably well (and by comparison to its peers it is a pretty good document) it is
full of specification sins\footnote{We don't mean this as an insult: without documents like these we couldn't do our work; and it is no worse---and in many ways better---than many such.} (see \cite{7sins}). For example, it is ambiguous concerning the number of and relationship between hierarchies; it
doesn't explain what the initial state of a control group is; it talks about tasks and processes as though they were the same without comment (we think they are the same, but we're not sure); the rules about the relationship between tasks and control groups sound contradictory; and so on.

We very much hope to address these puzzles (and more) in the following sections.

%=============================================================================
\section{Notes}

We gather here some observations, experiments and discussions which have informed our bit of research. This section may not survive the life of this specification, but we find it useful to try and document what we learn \emph{as we learn it}.

%----------------------------------------------------------------------------------------------------
\subsection{Mailing lists discussions}

It does not seem possible to define a \texttt{cgroup} hierarchy with no subsystems attached to it.
See the discussion \cite{noop}.

%----------------------------------------------------------------------------------------------------
\subsection{Experiments}
\label{sec:experiments}
We performed some simple experiments on a (virtual, and hence infinitely refreshable) Linux machine.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Multiple subsystems}

Attaching multiple subsystems to a single hierarchy:
{\small \begin{verbatim}
# cd /tmp/warden/cgroup
# mkdir test
# mount -t cgroup -o 'cpuset,blkio' none /tmp/warden/cgroup/test
# cd test
# mkdir parent
# cd parent
# echo 0 > cpuset.mems 
# echo 0 > cpuset.cpus
# echo $$ > tasks
# cat tasks
1840
2014
# cat /proc/1840/cgroup
13:blkio,cpuset:/parent
4:memory:/parent/child
3:devices:/
2:cpuacct:/
1:cpu:/
# cat /proc/cgroups
#subsys_name	hierarchy	num_cgroups	enabled
cpuset	13	2	1
cpu	1	1	1
cpuacct	2	1	1
memory	4	3	1
devices	3	1	1
freezer	0	1	1
blkio	13	2	1
perf_event	0	1	1
# cat /proc/mounts 
...
none /tmp/warden/cgroup tmpfs rw,relatime 0 0
none /tmp/warden/cgroup/cpu cgroup rw,relatime,cpu 0 0
none /tmp/warden/cgroup/cpuacct cgroup rw,relatime,cpuacct 0 0
none /tmp/warden/cgroup/devices cgroup rw,relatime,devices 0 0
none /tmp/warden/cgroup/memory cgroup rw,relatime,memory 0 0
none /tmp/warden/cgroup/test cgroup rw,relatime,blkio,cpuset 0 0
\end{verbatim}}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Multiple hierarchies}

Attaching a single subsystem to multiple hierarchies:
{\small \begin{verbatim}
$ pwd   
/home/vagrant
$ mkdir mem1
$ mkdir mem2
$ sudo su
# mount -t cgroup -o memory none /home/vagrant/mem1
# mount -t cgroup -o memory none /home/vagrant/mem2
# cd mem1
# mkdir inst1  
# ls inst1 
cgroup.clone_children  memory.failcnt ...
# ls ../mem2
cgroup.clone_children  inst1 memory.limit_in_bytes ...
# cd inst1
# echo 1000000 > memory.limit_in_bytes 
# cat memory.limit_in_bytes 
1003520
# cat ../../mem2/inst1/memory.limit_in_bytes 
1003520
# echo $$ > tasks
# cat tasks
1365
1409
# cat ../../mem2/inst1/tasks
1365
1411
\end{verbatim}}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Overlapping hierarchies}

Attaching a new subsystem to one of the hierarchies attached to an existing subsystem (this follows on from the previous experiment):
{\small \begin{verbatim}
# mount -t cgroup -o cpuset none /home/vagrant/mem1
# ls /home/vagrant/mem1
cpuset.cpus ... // No memory.* files!
# ls /home/vagrant/mem2
cgroup.clone_children  inst1 memory.limit_in_bytes ...
\end{verbatim}}

%=============================================================================
\section{Fundamentals}

We begin by describing some fundamental pieces of our description.

%----------------------------------------------------------------------------------------------------
\subsection{Given sets}
There are fundamental sets of items we will not look into, for example $TASK$s:
\begin{zed}
[TASK]
\end{zed}
which appear in collections in each control group.

There are $RESOURCE$s, which can be allocated, managed and monitored:
\begin{zed}
[RESOURCE]
\end{zed}
and which we will use to represent our abstract notion of a subsystem.

There are names, of which there are many types, here are two of them:
\begin{zed}
[SIMPLENAME, SSNAME]
\end{zed}
the simple names out of which control group (path)names are formed, and the subsystem names.

%----------------------------------------------------------------------------------------------------
\subsection{Sets of resources}

A subsystem will be concerned with resources, and we will model that by a set associated 
with a control group. It is simpler to start with the resource sets by themselves.

There is a $ResourceSet$ type:
\begin{zed}
ResourceSet == \finset RESOURCE
\end{zed}
a piece of state which holds one of them:
\begin{schema}{Resources}
rs : ResourceSet
\end{schema}
and these states begin by being empty:
\begin{zed}
InitResources \defs [ Resources' | rs' = \emptyset ]
\end{zed}

The basic operations not very interesting: simply adding and removing elements, which we expect happens
in batches (sets):

\begin{schema}{AddResources}
rs? : ResourceSet
\also
\Delta Resources
\where
rs' = rs \cup rs?
\end{schema}
where we just stick 'em all in.

\begin{schema}{RemoveResources}
rs? : ResourceSet
\also
\Delta Resources
\where
rs' = rs \setminus rs? 
\end{schema}
where we just take 'em all out.

These become more interesting when used in the context of a subsystem, for which see later.

%----------------------------------------------------------------------------------------------------
\subsection{A single control group}

A single control group in isolation is just a (finite) collection of tasks, and we can document this:

\begin{schema}{CGroup}
taskset : \finset TASK
\end{schema}

As a convenience, we define the (global) function $tasks$ which extracts the $taskset$ from a $CGroup$, and the
simple control group $EmptyCGroup$ which has no tasks in it:
\begin{zed}
tasks == (\lambda CGroup @ taskset)
\also
EmptyCGroup == (\mu CGroup | taskset = \emptyset )
\end{zed}

%----------------------------------------------------------------------------------------------------
\subsection{Control group path names}

Control groups have names, but these have a structure---a file directory-like structure---so we define them as \emph{sequences} of simple names (think of these as directory names), for which we use the shorthand $CGPath$:

\begin{zed}
CGPath == \seq SIMPLENAME
\end{zed}

There is a special name for the first (initial) control group, the root of the structure. We define a constant for it:

\begin{axdef}{}
ROOTCGROUPNAME : CGPath
\where
ROOTCGROUPNAME = \langle \rangle
\end{axdef}

There may be many $CGroup$s in the system, and a collection of $CGroup$ with names must `fill out' the tree-structure with $CGPath$ names. We explain this with a $NamedCGroups$ collection:

\begin{schema}{NamedCGroups}
cg : CGPath \ffun CGroup
\where
ROOTCGROUPNAME \in \dom cg \\
\forall s : \dom cg @ \forall t : CGPath | t \subset s @ t \in \dom cg
\end{schema}
The constraints imply that there is  at least one $CGroup$ in the collection (the root) and that the names are `prefix-closed'. The latter constraint is equivalent to saying the names fit together in a tree-structure (as in a file-system). 
There is a $CGroup$ for every node in the tree, `named' by the sequence of simple names from the root to the node.

We have said nothing about the \emph{tasks} in the $CGroup$s in the named collection.
This comes next.

%----------------------------------------------------------------------------------------------------
\subsection{System tasks}
In order to describe the relationship between named control groups and tasks, we need a minimal model of the tasks of the system. We first postulate a (fixed) initial task:

\begin{axdef}{}
INITIALTASK : TASK
\end{axdef}
and then we say that the tasks of the system always include this initial task:

\begin{schema}{Tasks}
systasks : \finset TASK
\where
INITIALTASK \in systasks
\end{schema}
which has the (pleasing) consequence that there is always at least one task in the system.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}

When the system tasks are first created, then, this $INITIALTASK$ must exist, which is to say that there is at least one task. We simplify it by saying there is exactly one (though we are not usually around to see this natal state).

\begin{schema}{InitTasks}
Tasks'
\where
\# systasks' = 1
\end{schema}
We may not need to use this property directly.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Creating a new task---lowest level}

We do need to speak about new task creation later, and so here is how we model it, from the point of view of $Tasks$:

\begin{schema}{CreateTask}
parent? : TASK \\
task! : TASK
\also
\Delta Tasks
\where
parent? \in systasks \\
task! \notin systasks \\
systasks' = systasks \cup \{ task! \}
\end{schema}
The new task has to have a (designated) parent, which is just any existing system task; the new task is not already
in the system and is inserted into the system, without disturbing any other tasks.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Destroying a task---lowest level}

Task destruction is also needed later in the context of control groups, but from the point of view of $Tasks$ we can say:

\begin{schema}{DestroyTask}
task? : TASK
\also
\Delta Tasks
\where
task? \in systasks \\
task? \neq INITIALTASK \\
systasks'  = systasks \setminus \{ task? \}
\end{schema}
The task being destroyed is already in the system; it must not be the system's initial task 
(this constraint could have been \emph{derived} since $Tasks'$ already insists that $INITIALTASK$ 
must remain in $systasks'$);
the task is removed from the set of system tasks, without disturbing the other tasks.

Of course we know there is a parent/child relationship between tasks which the system knows and maintains. 
We don't think we need to know about that (except at create time) so we don't model 
it\footnote{If we need this it will become clear later when we cannot express a constraint, 
or cannot describe a change of state correctly.}.

%=============================================================================
\section{Control group hierarchies}

Although it appears not possible to have a control group hierarchy without an attached subsystem 
(see section~\ref{sec:experiments}) we find it easier to consider hierarchies in isolation first.

We combine the named control groups and system tasks and say how they should be related. 
At the same time we describe a function $cgroup$ which maps each task to a control group in the collection.

We are defining a \emph{hierarchy} of control groups:

\begin{schema}{CGHierarchy}
Tasks \\
NamedCGroups
\also
cgroup : TASK \ffun CGPath
\where
tasks \circ cg \partition systasks
\also
\dom cgroup = systasks \\
\forall t : systasks @ t \in tasks ( cg (cgroup ~ t))
\end{schema}
Each task of the system is in precisely one control group, or, as expressed here, 
the control group tasks \emph{partition} the system tasks; 
\emph{and} there is a function ($cgroup$) which maps each system task to the (full) name 
($CGPath$) of the control group in which it resides.

We note that the existence of the function $cgroup$ is guaranteed by the partition requirement 
(on $tasks \circ cg$) that accompanies it. 
The function $cgroup$ is `derived state', and these assertions impose no extra constraints upon an hierarchy. 
In fact, the existence of $cgroup$ is \emph{equivalent} to the partition constraint.

It is legitimate to ask how a $CGHierarchy$ is initialised. 
We describe this next along with other operations on an hierarchy.


%----------------------------------------------------------------------------------------------------
\subsection{Hierarchy operations}

It is natural to consider state changes that might `happen' to hierarchies.
We will try to understand how an hierarchy is initialised, how new tasks enter or leave an hierarchy, 
and how tasks are moved between control groups in an hierarchy.
Then we can consider how a new control group of an hierarchy is created or destroyed.

Describing each of these operations precisely challenges our state descriptions and constraints---which helps us
to believe that they capture exactly what we want to say.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}

We first consider initialisation of an hierarchy. This is a sort of degenerate operation, as is common in Z specifications.

\begin{schema}{InitCGHierarchy}
CGHierarchy' \\
\Xi Tasks
\where
\exists CGroup' @ \\
( ~~~ cg' = \{ ~ ROOTCGROUPNAME \mapsto \theta CGroup' ~\} \\
\land taskset' = systasks' ~~)
\end{schema}
We here \emph{decide}\footnote{Although we here \emph{decide} this, 
we do not yet know if this is true. However, an assertion like this has the enormous advantage that it can be verified 
and tested, as can all of the state descriptions. If necessary we will come back and change it.}
that all existing system tasks are placed in the initial $CGroup$, 
with the special root name. 
Good job we declared it beforehand!

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{A single task operation skeleton}

Since $Tasks$ is part of our $CGHierarchy$ state, it is natural to want to use our description of system task operations $CreateTask$ 
and $DestroyTask$ when describing the (extra) effects upon an hierarchy. The create and destroy operation on
$Tasks$ can be elaborated to explain what happens on the extended state. 
In general this is called ``promotion'' and has well-trodden precedents in Z. Our usage here is more of an extension.

We first say what all of these extensions have in common (expressed as a ``promotion'' schema), 
which in our case says that fundamental task operations only affect a \emph{single task} in the hierarchy, while 
everything else remains fixed.

The $SingleTaskOp$ explains what remains fixed when performing a system task operation in an hierarchy. 
It is a skeleton operation schema which we can adapt to particular cases.

\begin{schema}{SingleTaskOp}
task : TASK
\also
\Delta CGHierarchy
\where
systasks' \setminus \{ task \} = systasks \setminus \{ task \}
\also
\{ task \} \ndres cgroup' = \{ task \} \ndres cgroup \\
\dom cg' = \dom cg
\end{schema}
This needs some explaining; the three clauses can be described thus:

Except possibly for $task$, the system tasks are unaffected (neither created nor destroyed).
Except for this same $task$, the association between tasks and their control group path names ($cgroup$) is unaffected.
The control group (directory) structure is likewise unaffected.

Note that, as we noted before, the map $cgroup'$, which is \emph{derived state}, 
uniquely determines the partition ($tasks \circ cg$) except possibly for
empty control groups. And, \emph{vice versa}, the partition determines the $cgroup$ map. 

Simply saying what the new $cgroup$ map should be and that no extra empty control groups arise 
(which is the force of $\dom cg = \dom cg'$) 
suffices to determine the rest of the new state, partition included.

With this skeleton\footnote{We notice, for the first time, just how symmetric this is: 
reverse all the (state) operations (swapping all primed states with their un-primed states---for 
example $cgroup'$ and $cgroup$ are exchanged) and we have the same promotion schema.}
we can describe the next operations easily.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Create a new task in an hierarchy}

Here we extend $CreateTask$ as a $SingleTaskOp$eration on an hierarchy.

\begin{schema}{CreateTaskInCG}
CreateTask \\
SingleTaskOp[task! / task]
\where
cgroup' ~ task! = cgroup ~ parent?
\end{schema}
The particular task is renamed to be the \emph{output} task (the one created). 
Everything else stays the same (see $SingleTaskOp$) and the new $task!$ goes in the $parent?$'s control group.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Destroy an existing task in an hierarchy}

Deleting a task from the system is even easier to explain:

\begin{schema}{DestroyTaskInCG}
DestroyTask \\
SingleTaskOp[task? / task]
\end{schema}
The particular task is renamed to be the \emph{input} task (the one to be deleted).
Everything else stays the same (see $SingleTaskOp$). 
No more needs to be said, since after $DestroyTask$ removes $task?$ from $systasks'$, 
everything else is `healed' by the constraints in the promotion.

We are heartened by this: $SingleTaskOp$ captures exactly what we mean by a `task-local' change,
and is sufficient to precisely describe the effects on the $CGHierarchy$ when such changes occur, excepting only 
when there is
an hierarchy-specific piece of information to supply.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Move a task from one control group to another}

Within an hierarchy we want to explain what happens if we move a task from one control group to another.
The system tasks are not changed by this, and we need to preserve the partitioning nature of the hierarchy. 
We need to supply the task which we are moving ($task?$), 
and the (full name of the) control group we are moving it to ($dest?$). 
We do not need to supply the control group it `moves from', because the hierarchy state has that information already.

This, it turns out, is another ``single task operation'', so we can use $SingleTaskOp$ again to help to explain it.

\begin{schema}{MoveCGroupTask}
dest? : CGPath
\also
SingleTaskOp[task? / task] \\
\Xi Tasks 
\where
task? \in systasks \\
dest? \in \dom cg
\also
cgroup' ~ task?  = dest?
\end{schema}
The constraints on the inputs are that the $task?$ exists already and 
the path ($dest?$) is the name of a known control group (of this hierarchy).
The new map $cgroup'$ must map $task?$ to the control group with path name $dest?$.

Amazingly, this is all we need to say. The last line implies that $task? \in \dom cgroup'$ and therefore
$tasks? \in systasks'$ too (from $CGHierarchy'$). 

$\Xi Tasks$ ensures that $task?$ must also be in $systasks$ before we start, so `the task exists already' is implied by the last line, although we prefer to be explicit about it.

The $SingleTaskOp$ constraints fix everything else for us.

It is instructive to consider what this operation specification implies if $dest? = cgroup ~ task?$, or in other words, if we
attempt to move a task to the control group it is already in. It should be clear that nothing changes in this case.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Create a new $CGroup$ in an hierarchy}

How does a new control group arise (in an hierarchy)?
Clearly we need to name it, and it must have an initial state, but there are also things to do with the
hierarchy that have to be true, and we mustn't disturb the task structure of the system when
creating a new control group, either:

\begin{schema}{CreateCGroup}
path? : CGPath
\also
\Delta CGHierarchy \\
\Xi Tasks
\where
path? \notin \dom cg \\
path? \neq ROOTCGROUPNAME \\
cg' = cg \cup \{ path? \mapsto EmptyCGroup \} \\
cgroup' = cgroup
\end{schema}
The control group path name is not an existing path (it's not in the old state); it cannot be the root; the new path must point to the empty control group, and the path must `fit' into the $cg$ map (see below); the task partition is unaffected.

What does it mean for the path to `fit'? It means that all its prefixes are in $\dom cg$ already. Equivalently, its immediate parent (the `front' of the sequence) is there.
The constraint which says `$path?$ is not the root', is strictly redundant (it can be derived from the other constraints).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Delete a $CGroup$ from an hierarchy}

When a control group is deleted, what happens to its tasks or its children (in the hierarchy)?
This is explained by saying that you can only destroy control groups that don't have tasks or children.
Here is how this can be formalised:

\begin{schema}{DestroyCGroup}
path? : CGPath
\also
\Delta CGHierarchy \\
\Xi Tasks
\where
path? \notin \dom cg' \\
path? \neq ROOTCGROUPNAME \\
cg = cg' \cup \{ path? \mapsto EmptyCGroup \} \\
cgroup' = cgroup
\end{schema}
The constraints say: this is not a new path (it's not in the new state); it cannot be the root; 
the path identifies the empty control group (in the old state); the task partition is unaffected.

Notice that the path \emph{used to}`fit' in $cg$, and if removing it leaves the $cg'$ structured correctly, 
this means it cannot have had any children beforehand.

The constraint which says `$path?$ is not the root', is \emph{also} redundant. 
It is harder to see why in this case, but removing the root would produce a $CGHierarchy'$ with an empty map $cg'$. 
The constraints on $CGHierarchy'$ (in particular from the $NamedCGroups'$ schema) prohibit this.

The constraints for $Create$... and $Destroy$... are deliberately symmetric.
Doing it this way helped us to (write and) understand them.

%=============================================================================
\section{Subsystems}

A $Subsystem$ is a collection of resource sets named by $CGPath$ names. We will eventually marry
this with a $GCHierarchy$, but we consider it in isolation first.
\begin{schema}{Subsystem}
res : CGPath \ffun ResourceSet
\also
pinned : \finset CGPath
\where
pinned = \dom(res \nrres \{ \emptyset \})
\end{schema}
Resource sets ``named by control group path names'' are represented by the map $res$; 
$pinned$ is derived state (completely determined by $res$) and consists of the control group path 
names which refer to non-empty resource sets\footnote{$\dom(res \nrres \{ \emptyset \})$ 
is a technical jewel, meaning the domain
of the relation which is that subset of $res$ consisting of pairs that relate names to the empty
resource set.}.

%----------------------------------------------------------------------------------------------------
\subsection{Subsystem operations}
We consider initialisation
and basic resource update operations, which we lift from the $Resources$ operations we had before.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}
We cannot say everything about the initial subsystem (until the $CGHierarchy$ is available), but we might try to
say:
\begin{zed}
%% \exists Subsystem' @
pinned' = \emptyset
\end{zed}
which doesn't tie down the domain of $res$, but at least says that there are no resources in its range.

\emph{This is a mistake.}  
There is \emph{no} guarantee that a subsystem initially uses \emph{no} resources---in fact it is
extremely likely that \emph{some} resources will be used by the tasks of the system which, remember, appear in the 
root of a hierarchy when
it is created. So we should not say anything about an \emph{initial} $Subsystem$. 
For completeness we will define the name though:
\begin{zed}
InitSubsystem \defs Subsystem'
\end{zed}
letting it `flap' completely (except for the usual subsystem state constraints, of course).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Lifting the resource set operations}
We want to add and remove resources from a particular resource set. In general we can say
how we lift an operation on resource sets to subsystems:

\begin{schema}{SubsystemResourcesOp}
cgp? : CGPath
\also
\Delta Subsystem \\
\Delta Resources
\where
cgp? \in \dom res \\
\{ cgp? \} \ndres res = \{ cgp? \} \ndres res' \\
res ~ cgp? = rs \\
res' ~ cgp? = rs'
\end{schema}
There is an input path name ($cgp?$) which must be a known name of the subsystem;
the resource sets (other than the one named $cgp?$) are not changed;
the resource set named $cgp?$ is changed in precisely the way that the $Resources$ operation changes
its resource set ($rs$ goes to $rs'$).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Add and remove resources}
When we combine $SubsystemResourcesOp$ with operations on $Resources$ 
(which include the signature $\Delta Resources$)
we get a lifted operation definition on $Subsystem$ except for the $\Delta Resources$ signature, 
which we can then hide.

\begin{zed}
AddSSResources \defs \\
\t2 \exists \Delta Resources @ ( AddResources \land SubsystemResourcesOp )
\also
RemoveSSResources \defs \\
\t2 \exists \Delta Resources @ ( RemoveResources \land SubsystemResourcesOp )
\end{zed}
The $\exists \Delta Resources @$ prefix is just a clumsy way of hiding the $Resources$ and $Resources'$ states
which we only needed to expose to explain the lifting, and should not be exposed on the 
subsystem operation.

Are these \emph{really} operations on $Subsystem$?

We can demonstrate that they are by deriving the ``signature'' of, for example, $AddSSResources$, 
and it works out as\footnote{Not really,
for we have preserved some constraints in the declarations to make it easier to relate to our other operations.}:

\begin{schema*}
rs? : ResourceSet\\
cgp? : CGPath\\
\Delta Subsystem
\end{schema*}
which is clearly an operation with inputs $rs?$, a set of resources, and $cgp?$, a path name, as we would expect.

%=============================================================================
\section{Attached subsystems}
$Subsystem$s are pretty an\ae{}mic because they are not yet `attached' to a hierarchy. This is what we describe next.

\begin{schema}{AttachedSubsystem}
Subsystem \\
CGHierarchy
\where
\dom res = \dom cg
\end{schema}
The control group paths that the subsystem tracks are precisely the ones in
the attached hierarchy. 

%----------------------------------------------------------------------------------------------------
\subsection{Attached subsystem operations}
The operations on $CGHierarchy$ and those on $Subsystem$ can now be lifted to $AttachedSubsystem$
by similar lifting mechanisms we used before. The constraints (aka preconditions) imposed 
by $CGHierarchy$ and $Subsystem$ operations combine via the
$AttachedSubsystem$ constraint, to enable us to derive many (but not all) of the preconditions of the lifted operations.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Initialisation}

The initially attached subsystem ought to be a simple combination of initial subsystem and initial hierarchy; and it is:

\begin{zed}
InitAttachedSubsystem \defs \\
\t1 AttachedSubsystem' \land InitSubsystem \land InitCGHierarchy
\end{zed}
simplesh.

Notice that the resources used by the initial (root) control group might be anything---we had to allow this when
explaining $InitSubsystem$.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Operations lifted from $CGHierarchy$}

In $CGHierarchy$ operations we created a new task, destroyed an existing task, moved a task and created and destroyed
a control group.  All of these occur when a subsystem is attached to the hierarchy, and we can explain the \emph{extra}
constraints easily enough.

In each case the hierarchy changes are already stipulated, we only have to say what happens to the subsystem that is
tracking it.

\subparagraph{Create a task:}
We have to explain what parts of the subsystem may change when a new task is created:

\begin{schema}{CreateTaskInAttachedCGH}
\Delta AttachedSubsystem \\
CreateTaskInCG
\where
\LET cgp == cgroup' ~ task! @ \\
\t1 \{cgp\} \ndres res = \{cgp\} \ndres res' \land \\
\t1 res ~ cgp \subseteq res' ~ cgp
\end{schema}
Here we've introduced a local shorthand $cgp$ for $cgroup' ~ task!$, the name of the control group which contains
the new task ($task!$); the resource-set map, $res$, remains the same on all control groups except this one;
on this one the resource set usage may increase (but it cannot decrease).

This is intentionally non-deterministic because we cannot say what resources a new task might require or 
what its parent might require. In general, then, we might add resources into the control group.

Note that it is possible for the $pinned$ set to increase but only by the addition of the single control group 
named $cgp$.

\subparagraph{Destroy a task:}
We have to explain what parts of the subsystem may change when a task is destroyed:

\begin{schema}{DestroyTaskInAttachedCGH}
\Delta AttachedSubsystem \\
DestroyTaskInCG
\where
\LET cgp == cgroup ~ task? @ \\
\t1 \{cgp\} \ndres res = \{cgp\} \ndres res' \land \\
\t1 res' ~ cgp \subseteq res ~ cgp
\end{schema}
Shorthand again;  the resource-set map, $res$, remains the same on all control groups except this one;
on this one the resource set usage may \emph{decrease} (but it cannot increase).

Here the $pinned$ set might reduce by one control group, but only one.

\subparagraph{Move a task:}
We have to explain what parts of the subsystem may change when a task is moved from one control group to another.

\begin{schema}{MoveTaskInAttachedCGH}
\Delta AttachedSubsystem \\
MoveCGroupTask
\where
\LET src == cgroup ~ task? @ \\
\t1 \{src, dest?\} \ndres res = \{src, dest?\} \ndres res' \land \\
\t1 res' ~ src \subseteq res ~ src \land \\
\t1 res ~ dest? \subseteq res' ~ dest?
\end{schema}
This time we introduce local shorthand for the source control group ($src$); 
the $res$ map remains unchanged on all control groups except possibly for the source and destination control groups;
the source control group resources might decrease;
the destination control group resources might increase.

We are tempted to say that the resources transfer from one control group to the other; but we cannot say this. 
In general the transfer may involve extra resources, or it may reduce the resources used. Particular
subsystems might be able to say more about this.

Again it is instructive to consider what happens if the source and destination are the same control group. The specification implies that this is a no-op: the resources used are unchanging. It remains to be seen if this is the case,
but we would be surprised if it wasn't.  It is nice to see this falling out of a general description.

\subparagraph{Create a control group:}
We have to explain what parts of the subsystem may change when a new control group is created:

\begin{schema}{CreateCGroupInAttachedCGH}
\Delta AttachedSubsystem \\
CreateCGroup
\where
res' ~ path? = \emptyset \\
res = \{path?\} \ndres res' 
\end{schema}
The new control group uses no resources (and has no tasks you may recall from $CreateCGroup$); the resources
for all the other control groups remain the same. Notice how the $\Delta AttachedSubsystem$ constraints save us
from having to say stuff like `no other control groups magically appear'.

\subparagraph{Destroy a control group:}
We have to explain what parts of the subsystem may change when a control group is destroyed:

\begin{schema}{DestroyCGroupInAttachedCGH}
\Delta AttachedSubsystem \\
DestroyCGroup
\where
res ~ path? = \emptyset \\
res' = \{path?\} \ndres res 
\end{schema}
The control group being destroyed \emph{must not be using any resources};
the resources for all the other control groups remain 
the same. 

Not using any resources tallies with the $CGHierarchy$ operation constraint that it must have no tasks when it is
destroyed, although not having tasks doesn't imply it is not using resources).

We also get the parent-child restrictions for free (ultimately from $NamedCGroups$).

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Operations lifted from $Subsystem$}

Adding or removing resources rom a particular control group has no effect on the structure or the tasks
in an hierarchy.

We can therefore lift the $Add$ and $Remove$ resources operations directly as follows:

\begin{zed}
AddResourcesInAttachedSubsystem \defs \\
\t1 AddSSResources \land \Delta AttachedSubsystem \land \Xi CGHierarchy
\also
RemoveResourcesInAttachedSubsystem \defs \\
\t1 RemoveSSResources \land \Delta AttachedSubsystem \land \Xi CGHierarchy
\end{zed}
where $\Xi CGHierarchy$ documents that the hierarchy remains unchanged.

\clearpage

\appendix

\begin{flushleft}
\begin{thebibliography}{99}   
% `99' is a picture of the generated numeric references -- they are two digits in this bibliography 
% If we had a hundred or more we would have used 999, or whatever.

%%  Example bibliography entry:
%\bibitem{knuth76}                                                        % citation callout, e.g.: \cite{knuth76}
%  Donald E. Knuth,                                                        % author
%  \emph{The computer as Master Mind}.                    % title
%  J. Recreational Mathematics, Vol.~9(1), 1976-1977. % publisher, or journal, volume and date

\bibitem{warden}
  Various authors,
  \emph{Warden github repository},
  \texttt{https://github.com/cloudfoundry/warden}.

\bibitem{garden}
  Various authors,
  \emph{Garden github repository}, 
  \texttt{https://github.com/pivotal-cf-experimental/garden}.

% API abstracting the cgroup filesystem
% See http://manpages.ubuntu.com/manpages/lucid/man5/cgconfig.conf.5.html for configuration containing useful insights
\bibitem{libcgroup}
  Various authors
  \emph{libcgroup},
  {\small \texttt{http://libcg.sourceforge.net/html/index.html}}.

\bibitem{linuxgroups}
  Paul Menage, Paul Jackson and Christoph Lameter,
  \emph{CGROUPS},
  {\small \texttt{https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt}}, 2004-2006.

\bibitem{linuxkernel}
  Linus Torvalds, \emph{et al},
  \emph{Linux kernel source tree},
  {\small \texttt{https://github.com/torvalds/linux}}.

\bibitem{memory}
  Various authors,
  \emph{Memory Resource Controller},
  {\small \texttt{https://www.kernel.org/doc/Documentation/cgroups/memory.txt}}.

\bibitem{noop}
  Kamezawa Hiroyuki, \emph{et al},
  \emph{NOOP cgroup subsystem},
  {\small \texttt{http://thread.gmane.org/gmane.linux.kernel/777763}}.

\bibitem{rharticle}
  Martin Prpi\u{c}, R\"udiger Landmann, and Douglas Silas,
  \emph{Red Hat Enterprise Linux 6.5 GA: Resource Management Guide}, 
  {\small \texttt{https://access.redhat.com/site/documentation/en-US\slash{}Red\_Hat\_Enterprise\_Linux/6/pdf/Resource\_Management\_Guide\slash{}Red\_Hat\_Enterprise\_Linux-6-Resource\_Management\_Guide-en-US.pdf}}.

\bibitem{7sins}
  Bertrand Meyer,
  \emph{On Formalism In Specifications},
  IEEE Software, Vol.~2(1), 1985.
\end{thebibliography}
\end{flushleft}
\end{document}
