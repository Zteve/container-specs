\documentclass[a4paper,twoside,12pt]{article}
\usepackage{zed-cm}
\usepackage{graphicx}
\markboth{Draft}{Version 0.1}
\pagestyle{myheadings}
\begin{document}
\parskip 2 pt
\parindent 10 pt

\def\Slash{\slash\hspace{0pt}}

\title{A Model of Linux Control Groups}

\author{
Glyn Normington\and
Steve Powell
}

\maketitle
% The following three commands ensure the title page is stamped as
% confidential without a page number. Page numbering is started at the
% table of contents.
\thispagestyle{myheadings}
\pagenumbering{roman}
\setcounter{page}{1}

%=============================================================================

This is a working document which serves to record the justifications, deliberations and results of an attempt to
specify precisely some (or all) of the features of \emph{Linux Control Groups} which can support robust and reliable development of \emph{Warden} and related products.

% Alt-Cmd-M -- \emph{}
% Alt-Cmd-Z -- \zed{}
% Alt-Cmd-X -- \axdef{}
% Alt-Cmd-S -- \schema{}
% Alt-Shift-Cmd-T -- \texttt{}

% Type checking hacks
\newcommand{\true}{true}
\newcommand{\false}{false}
\renewcommand{\emptyset}{\varnothing}
%=============================================================================

\clearpage
\tableofcontents

\begin{flushleft}
\begin{thebibliography}{99}   % `99' is a picture of the generated numeric references -- they are two digits in this bibliography

%%  Example bibliography entry:
%\bibitem{knuth76} % citation callout, e.g.: \cite{knuth76}
%  Donald E. Knuth, % author
%  \emph{The computer as Master Mind}. % title
%  J. Recreational Mathematics, Vol.~9(1), 1976-1977. % publisher, or journal, volume and date

\bibitem{warden}
  Various authors,
  \emph{Warden github repository},
  \texttt{https://github.com/cloudfoundry/warden}.

\bibitem{garden}
  Various authors,
  \emph{Garden github repository}, 
  \texttt{https://github.com/pivotal-cf-experimental/garden}.

\bibitem{linuxgroups}
  Paul Menage, Paul Jackson and Christoph Lameter,
  \emph{CGROUPS}
  \texttt{https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt}, 2004-2006.

\bibitem{linuxkernel}
  Linus Torvalds, \emph{et al},
  \emph{Linux kernel source tree}
  \texttt{https://github.com/torvalds/linux}.

\bibitem{memory}
  Various authors,
  \emph{Memory Resource Controller}
  \texttt{https://www.kernel.org/doc/Documentation/cgroups/memory.txt}.

\bibitem{rharticle}
  Martin Prpi(?), RŸdiger Landmann, and Douglas Silas,
  \emph{Red Hat Enterprise Linux 6.5 GA: Resource Management Guide}, 
  \texttt{https://access.redhat.com/site/documentation/en-US\slash{}Red\_Hat\_Enterprise\_Linux/6/pdf/Resource\_Management\_Guide\slash{}Red\_Hat\_Enterprise\_Linux-6-Resource\_Management\_Guide-en-US.pdf}.

\end{thebibliography}
\end{flushleft}

\clearpage
\pagenumbering{arabic}

%=============================================================================
\section{Introduction}

In order to implement some features and improvements to \emph{Warden} we intend to sharpen our understanding of Linux Control Groups and simultaneously document their use.

Linux Control Groups are the basis for the current implementation of Warden as well as of Linux Containers (LXC), Docker, and Google's
\textit{lmctfy} ("let me contain that for you") project and so are important to the industry as well as to the parochial interests of Cloud
Foundry.

In the process we intend to use our improved understanding to benefit:
\begin{itemize}
\item Linux Kernel documentation;
\item Warden \cite{warden} and Garden \cite{garden} development and exploitation; and
\item the wider development audience.
\end{itemize}
In particular, a clearer understanding of Warden/Garden and their basis in Linux Control Groups will put development of Warden/Garden
on a much firmer footing and enable key abstractions to be introduced which will provide a much-needed, stable structure around which
functional enhancements and the likely future evolution of Linux Control Groups can fit.

These are the deliverables we plan:

\begin{itemize}
\item \emph{CGroupSpec}: a precise Z specification for Control Groups, and (at least) the Memory Subsystem, states;
\item an improved introduction (for Z0L readers\footnote{\emph{Z0L} refers to people who do not speak Z; Z is their \emph{zero}th language.}) of Control Groups, etc.;
\item \emph{WardenSpec}: a precise Z specification for a Warden API, using some or all of the \emph{CGroupSpec} state;
\item an english version of the same (for Z0L readers);
\item an implementation framework that maps \emph{WardenSpec} to \emph{CGroupSpec};
\item proposals for future development of Warden functionality by reference to these specs.
\end{itemize}
As input to this work we access the following sources of information:

\begin{description}
\item[Kernel specs] the english descriptions of Control Groups in the Kernel literature \cite{linuxgroups};
\item[Kernel code] the Linux Kernel \cite{linuxkernel};
\item[experiments] tests run against the CGroups kernel code (on a shared VM);
\item[RedHat article] an article about CGroups written by RedHat which provides some invariants of the pseudo-filesystem state \cite{rharticle}.
\end{description}

\subsection{The Linux specification \cite{linuxgroups}}

In order to kick off the discussion (and to show what we're up against) I include the first section of \cite{linuxgroups} here:

\begin{verbatim}
1.1 What are cgroups ?
----------------------

Control Groups provide a mechanism for aggregating/partitioning sets of
tasks, and all their future children, into hierarchical groups with
specialized behaviour.

Definitions:

A *cgroup* associates a set of tasks with a set of parameters for one
or more subsystems.

A *subsystem* is a module that makes use of the task grouping
facilities provided by cgroups to treat groups of tasks in
particular ways. A subsystem is typically a "resource controller" that
schedules a resource or applies per-cgroup limits, but it may be
anything that wants to act on a group of processes, e.g. a
virtualization subsystem.

A *hierarchy* is a set of cgroups arranged in a tree, such that
every task in the system is in exactly one of the cgroups in the
hierarchy, and a set of subsystems; each subsystem has system-specific
state attached to each cgroup in the hierarchy.  Each hierarchy has
an instance of the cgroup virtual filesystem associated with it.

At any one time there may be multiple active hierarchies of task
cgroups. Each hierarchy is a partition of all tasks in the system.

User-level code may create and destroy cgroups by name in an
instance of the cgroup virtual file system, specify and query to
which cgroup a task is assigned, and list the task PIDs assigned to
a cgroup. Those creations and assignments only affect the hierarchy
associated with that instance of the cgroup file system.

On their own, the only use for cgroups is for simple job
tracking. The intention is that other subsystems hook into the generic
cgroup support to provide new attributes for cgroups, such as
accounting/limiting the resources which processes in a cgroup can
access. For example, cpusets (see Documentation/cgroups/cpusets.txt) allow
you to associate a set of CPUs and a set of memory nodes with the
tasks in each cgroup.
\end{verbatim}

\section{Control Groups}

We begin by attempting to describe Control Groups.

\subsection{Fundamentals}
There are a number of fundamental sets of items we will not look into. There are $TASK$s, and there are $NAME$s. To begin with, only Control Groups have names, in our world.

\begin{zed}
[TASK, NAME]
\end{zed}

There is a special name for the first (initial) Control Group, which we need not know explicitly, but we define a constant to refer to it by:

\begin{axdef}{}
INITCGROUPNAME : NAME
\end{axdef}

Now, as far as a (single) Control Group is concerned it is just a (finite) collection of tasks, and we can document this:

\begin{schema}{CGroup}
taskset : \finset TASK
\end{schema}
and do not feel the need to constrain this further (at the moment).

As a convenience, we can define the function $tasks$ which maps a $CGroup$ to its $taskset$:
\begin{zed}
tasks == (\lambda CGroup @ taskset)
\end{zed}

There are many $CGroup$s in the system, and the collection is where the names are associated with each group. Furthermore, the collection of $CGroup$s as a whole has a constraint on it: no task appears in more than one $CGroup$. We express this by talking about a collection of $CGroup$s. Because it is not the whole story, we shall name it $CGroupsBase$:

\begin{schema}{CGroupsBase}
cg : NAME \ffun CGroup
\where
\disjoint tasks \circ cg
\end{schema}
The $\disjoint$ line is the one expressing the constraint on tasks being assigned to at most one $CGroup$.

We would like to say also that every task in the system is assigned to \emph{at least} one $CGroup$, but we do not yet know what ``every task in the system'' means. This comes later.

\subsection{System Tasks}
In order to describe the relationship between Control Groups and the tasks of the system as a whole, we will model the tasks of the system separately:

\begin{schema}{Tasks}
systasks : \finset TASK \\
initialTask : TASK
\where
initialTask \in systasks
\end{schema}
where there is an $initialTask$, which is the first task of the system.

When this set of tasks is created, this $initialTask$ must exist:

\begin{schema}{InitTasks}
Tasks'
\where
\# systasks' = 1
\end{schema}
\section{Subsystems}
We may not need this refinement.

\subsection{Groups and Tasks together}
Now we can combine the Control Groups and system tasks and say how they should be related:

\begin{schema}{CGroupTasks}
Tasks \\
CGroupsBase \\
cgroup : TASK \ffun NAME
\where
tasks \circ cg \partition systasks
\end{schema}

\section{The Hierarchy}

\end{document}
