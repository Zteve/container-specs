\documentclass[a4paper,twoside,12pt]{article}
\usepackage{zed-cm}
\usepackage{graphicx}
\markboth{Draft}{Version 0.1}
\pagestyle{myheadings}
\begin{document}
\parskip 2 pt
\parindent 10 pt

\def\Slash{\slash\hspace{0pt}}

\title{A Model of Linux Control Groups}

\author{
Glyn Normington\and
Steve Powell
}

\maketitle
% The following three commands ensure the title page is stamped as
% confidential without a page number. Page numbering is started at the
% table of contents.
\thispagestyle{myheadings}
\pagenumbering{roman}
\setcounter{page}{1}

%=============================================================================

This is a working document which serves to record the justifications, deliberations and results of an attempt to
specify precisely some (or all) of the features of \emph{Linux Control Groups} which can support robust and reliable development of \emph{Warden} and related products.

\paragraph{Current ``to-do'' list:}
\begin{itemize}
\item \emph{ops}--- describe more operations (e.g. on $CGroupsTasks$);
\item \emph{hierarchy}--- describe trees of $CGroup$s;
\item \emph{subsystem}--- describe subsystems and attachment to $CGroup$s;
\item \emph{RedHat rule 2}--- make rule 2 into a constraint on subsystems+hierarchies;
\item \emph{RedHat rules}--- ensure all RedHat rules are represented correctly.
\end{itemize}


% Alt-Cmd-M -- \emph{}
% Alt-Cmd-Z -- \zed{}
% Alt-Cmd-X -- \axdef{}
% Alt-Cmd-S -- \schema{}
% Alt-Shift-Cmd-T -- \texttt{}

% Type checking hacks
\newcommand{\true}{true}
\newcommand{\false}{false}
\renewcommand{\emptyset}{\varnothing}
%=============================================================================

\clearpage
\tableofcontents

\clearpage
\pagenumbering{arabic}

%=============================================================================
\section{Introduction}

In order to implement some features and improvements to \emph{Warden} we intend to sharpen our understanding of Linux Control Groups and simultaneously document their use.

Linux Control Groups are the basis for the current implementation of Warden as well as of Linux Containers (LXC), Docker, and Google's
\textit{lmctfy} (``\emph{l}et \emph{m}e \emph{c}ontain \emph{t}hat \emph{f}or \emph{y}ou'') project and so are important to the industry as well as to the parochial interests of Cloud
Foundry.

In the process we intend to use our improved understanding to benefit:
\begin{itemize}
\item Linux Kernel documentation;
\item Warden \cite{warden} and Garden \cite{garden} development and exploitation; and
\item the wider development audience.
\end{itemize}
In particular, a clearer understanding of Warden/Garden and their basis in Linux Control Groups will put development of Warden/Garden
on a much firmer footing and enable key abstractions to be introduced which will provide a much-needed, stable structure around which
functional enhancements and the likely future evolution of Linux Control Groups can fit.

These are the deliverables we plan:

\begin{itemize}
\item \emph{CGroupSpec}: a precise Z specification for Control Groups, and (at least) the Memory Subsystem, states;
\item an improved introduction (for Z0L readers\footnote{\emph{Z0L} refers to people who do not speak Z; Z is their \emph{zero}th language.}) of Control Groups, etc.;
\item \emph{WardenSpec}: a precise Z specification for a Warden API, using some or all of the \emph{CGroupSpec} state;
\item an english version of the same (for Z0L readers);
\item an implementation framework that maps \emph{WardenSpec} to \emph{CGroupSpec}; and
\item proposals for future development of Warden functionality by reference to these specs.
\end{itemize}
As input to this work we access the following sources of information:
\begin{description}
\item[Kernel specs] the english descriptions of Control Groups in the Kernel literature \cite{linuxgroups};
\item[Kernel code] the Linux Kernel \cite{linuxkernel};
\item[experiments] tests run against the CGroups kernel code (on a shared VM);
\item[RedHat article] an article about CGroups written by RedHat which provides some invariants of the pseudo-filesystem state \cite{rharticle}.
\end{description}

%----------------------------------------------------------------------------------------------------
\subsection{The Linux specification \cite{linuxgroups}}

In order to kick off the discussion (and to show what we're up against) I include the first section of \cite{linuxgroups} here:

\begin{verbatim}
1.1 What are cgroups ?
----------------------

Control Groups provide a mechanism for aggregating/partitioning sets of
tasks, and all their future children, into hierarchical groups with
specialized behaviour.

Definitions:

A *cgroup* associates a set of tasks with a set of parameters for one
or more subsystems.

A *subsystem* is a module that makes use of the task grouping
facilities provided by cgroups to treat groups of tasks in
particular ways. A subsystem is typically a "resource controller" that
schedules a resource or applies per-cgroup limits, but it may be
anything that wants to act on a group of processes, e.g. a
virtualization subsystem.

A *hierarchy* is a set of cgroups arranged in a tree, such that
every task in the system is in exactly one of the cgroups in the
hierarchy, and a set of subsystems; each subsystem has system-specific
state attached to each cgroup in the hierarchy.  Each hierarchy has
an instance of the cgroup virtual filesystem associated with it.

At any one time there may be multiple active hierarchies of task
cgroups. Each hierarchy is a partition of all tasks in the system.

User-level code may create and destroy cgroups by name in an
instance of the cgroup virtual file system, specify and query to
which cgroup a task is assigned, and list the task PIDs assigned to
a cgroup. Those creations and assignments only affect the hierarchy
associated with that instance of the cgroup file system.

On their own, the only use for cgroups is for simple job
tracking. The intention is that other subsystems hook into the generic
cgroup support to provide new attributes for cgroups, such as
accounting/limiting the resources which processes in a cgroup can
access. For example, cpusets (see Documentation/cgroups/cpusets.txt) allow
you to associate a set of CPUs and a set of memory nodes with the
tasks in each cgroup.
\end{verbatim}
Although this reads reasonably well (and by comparison to its peers it is a pretty good document) it is
full of specification sins\footnote{We don't mean this as an insult: without documents like these we couldn't do our work; and it is no worse --- and in many ways better --- than many such documents in the net.}. For example, it is ambiguous concerning the number and relationship between hierarchies; it
doesn't explain what the initial state of a Control Group is; it talks about tasks and processes as though they were the same thing (they are!); the rules about the relationship between tasks and Control Groups sound contradictory; and so on.

We very much hope to address these puzzles (and more) in the following sections.

%=============================================================================
\section{Notes}

%----------------------------------------------------------------------------------------------------
\subsection{Mailing Lists}

It does not seem possible to define a cgroup hierarchy with no subsystems attached to it.
See the discussion \cite{noop}.

%----------------------------------------------------------------------------------------------------
\subsection{Experiments}

Attaching multiple subsystems to a single hierarchy:
\begin{verbatim}
# cd /tmp/warden/cgroup
# mkdir test
# mount -t cgroup -o 'cpuset,blkio' none /tmp/warden/cgroup/test
# cd test
# mkdir parent
# cd parent
# echo 0 > cpuset.mems 
# echo 0 > cpuset.cpus
# echo $$ > tasks
# cat tasks
1840
2014
# cat /proc/1840/cgroup
13:blkio,cpuset:/parent
4:memory:/parent/child
3:devices:/
2:cpuacct:/
1:cpu:/
# cat /proc/cgroups
#subsys_name	hierarchy	num_cgroups	enabled
cpuset	13	2	1
cpu	1	1	1
cpuacct	2	1	1
memory	4	3	1
devices	3	1	1
freezer	0	1	1
blkio	13	2	1
perf_event	0	1	1
# cat /proc/mounts 
...
none /tmp/warden/cgroup tmpfs rw,relatime 0 0
none /tmp/warden/cgroup/cpu cgroup rw,relatime,cpu 0 0
none /tmp/warden/cgroup/cpuacct cgroup rw,relatime,cpuacct 0 0
none /tmp/warden/cgroup/devices cgroup rw,relatime,devices 0 0
none /tmp/warden/cgroup/memory cgroup rw,relatime,memory 0 0
none /tmp/warden/cgroup/test cgroup rw,relatime,blkio,cpuset 0 0
\end{verbatim}

Attaching a single subsystem to multiple hierarchies:
\begin{verbatim}
$ pwd   
/home/vagrant
$ mkdir mem1
$ mkdir mem2
$ sudo su
# mount -t cgroup -o memory none /home/vagrant/mem1
# mount -t cgroup -o memory none /home/vagrant/mem2
# cd mem1
# mkdir inst1  
# ls inst1 
cgroup.clone_children  memory.failcnt ...
# ls ../mem2
cgroup.clone_children  inst1 memory.limit_in_bytes ...
# cd inst1
# echo 1000000 > memory.limit_in_bytes 
# cat memory.limit_in_bytes 
1003520
# cat ../../mem2/inst1/memory.limit_in_bytes 
1003520
# echo $$ > tasks
# cat tasks
1365
1409
# cat ../../mem2/inst1/tasks
1365
1411
\end{verbatim}

Attaching a new subsystem to one of the hierarchies attached to an existing subsystem (this follows on from the previous experiment):
\begin{verbatim}
# mount -t cgroup -o cpuset none /home/vagrant/mem1
# ls /home/vagrant/mem1
cpuset.cpus ... // No memory.* files!
# ls /home/vagrant/mem2
cgroup.clone_children  inst1 memory.limit_in_bytes ...
\end{verbatim}

%=============================================================================
\section{Control Groups}

We begin by attempting to describe Control Groups.

%----------------------------------------------------------------------------------------------------
\subsection{Fundamentals}
There are fundamental sets of items we will not look into, for example $TASK$s.
\begin{zed}
[TASK]
\end{zed}

Control Groups will have names, but these turn out to have a structure --- a file directory structure --- so we should define them as sequences of ``directory'' names. The latter we will not define.

\begin{zed}
[NAME]
\end{zed}
and now Control Group names are sequences of these:

\begin{zed}
CGPath == \seq NAME
\end{zed}

To begin with, only Control Groups have names, in our world.

There is a special name for the first (initial) Control Group, the root. We define a constant for it:

\begin{axdef}{}
ROOTCGROUPNAME : CGPath
\where
ROOTCGROUPNAME = \langle \rangle
\end{axdef}

Now, as far as a (single) Control Group is concerned it is just a (finite) collection of tasks, and we can document this:

\begin{schema}{CGroup}
taskset : \finset TASK
\end{schema}
and do not feel the need to constrain this further (at the moment).

As a convenience, we can define the function $tasks$ which maps a $CGroup$ to its $taskset$:
\begin{zed}
tasks == (\lambda CGroup @ taskset)
\end{zed}

There are many $CGroup$s in the system, and the collection is where the names are associated with each group. Furthermore, the collection of $CGroup$s as a whole has a constraint on it: no task appears in more than one $CGroup$. We express this by talking about a collection of $CGroup$s. Because it is not the whole story, we shall name it $CGroupsBase$. The collections must form a hierarchy.

\begin{schema}{CGroupsBase}
cg : CGPath \ffun CGroup
\where
ROOTCGROUPNAME \in \dom cg \\
\forall s : \dom cg @ \forall t : CGPath | t \subset s @ t \in \dom cg
\also
\disjoint tasks \circ cg
\end{schema}

There is at minimum a root Control Group in the collection.  The collection is named in a hierarchy (the constraint describes this as `prefix-closed') which is just like a file-system structure.

The $\disjoint$ line is the one expressing the constraint on tasks being assigned to at most one $CGroup$ in the collection.

We would like to say also that every task in the system is assigned to \emph{at least} one $CGroup$, but we do not yet know what ``every task in the system'' means. This comes next.

%----------------------------------------------------------------------------------------------------
\subsection{System Tasks}
In order to describe the relationship between Control Groups and the tasks of the system as a whole, we will model the tasks of the system separately:

\begin{schema}{Tasks}
systasks : \finset TASK \\
initialTask : TASK
\where
initialTask \in systasks
\end{schema}
where there is an $initialTask$, which is the first task of the system.

When this set of tasks is created, this $initialTask$ must exist:

\begin{schema}{InitTasks}
Tasks'
\where
\# systasks' = 1
\end{schema}
\section{Subsystems}
We may not need this refinement.

%----------------------------------------------------------------------------------------------------
\subsection{Groups and Tasks together}
Now we can combine the Control Groups and system tasks and say how they should be related. At the same time we can describe a function $cgroup$ which relates each task to the name of its (unique) Control Group.

\begin{schema}{CGroupsTasks}
Tasks \\
CGroupsBase
\also
cgroup : TASK \ffun CGPath
\where
tasks \circ cg \partition systasks
\also
\dom cgroup = systasks \\
\forall t : systasks @ t \in tasks ( cg (cgroup ~ t))
\end{schema}
where: each task of the system is in precisely one Control Group, or, as expressed here, the Control Group tasks \emph{partition} the system tasks; and there is a function ($cgroup$) which maps each system task to the name of the Control Group in which it resides.

It is important to note that the existence of the function $cgroup$ is guaranteed by the partition requirement that accompanies it. It is what is called `derived state', and these assertions impose no extra constraints. In fact, the existence of $cgroup$ is \emph{equivalent} to the partition constraint.

It is legitimate to ask how the collection of Control Groups and Tasks is initialised.

\begin{schema}{InitCGroupsTasks}
CGroupsTasks' \\
\Xi Tasks
\where
\exists CGroup' @ \\
( ~~~ cg' = \{ ~ ROOTCGROUPNAME \mapsto \theta CGroup' ~\} \\
\land taskset' = systasks' ~~)
\end{schema}
We here decide that all existing system tasks are placed in the initial $CGroup$, with a standard initial name. Good job we declared it beforehand!

Although we have decided this, we do not yet know if this is true. However, an assertion like this has the enormous advantage that it can be verified and tested, as can all of the state descriptions. If necessary we can come back and change it.

%----------------------------------------------------------------------------------------------------
\subsection{Operations}

After initialisation it is natural to consider operations that might `happen' to Control Groups. We will try to understand how tasks are moved between Control Groups, how a new task is inserted (into the system, and therefore into the groups), how a new Control Group is created, and how tasks and Control Groups are deleted. Describing each of these operations challenges our state descriptions and constraints---which is a good thing.

% \begin{schema}{NewCGroup}
% \end{schema}
% \begin{schema}{DeleteCGroup}
% \end{schema}
% \begin{schema}{NewCGroupTask}
% \end{schema}
% \begin{schema}{DeleteCGroupTask}
% \end{schema}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsubsection{Move a task from one $CGroup$ to another}

Within a collection of $CGroup$s (in a $CGroupsTasks$ state) we want to explain what happens if we move a task from one Control Group to another.

The system tasks are not changed by this, and we need to preserve the partitioning nature of the collection of Control Groups. We need to supply the task which we are moving ($t?$), and the (name of the) Control Group we are moving it to ($dest?$). (We do not need to supply the name of the Control Group it `comes from', because the state has that information.)

\begin{schema}{MoveCGroupTask}
t? : TASK \\
dest? : CGPath
\also
\Delta CGroupsTasks \\
\Xi Tasks 
\where
t? \in systasks \\
dest? \in \dom cg
\also
cgroup' = cgroup \oplus \{ ~t? \mapsto dest? ~\}
\end{schema}
Amazingly, this is all we need to say.  The constraints on the inputs are that the task is a real one in the system and that the name is the name of a known Control Group (of this collection).

The new $cgroup$ map is the same as the old one, except that the input task, $t?$, is now mapped to the Control Group named $dest?$.

The map $cgroup$, which we noted above was part of the derived state, uniquely determines the partition (and \emph{vice versa}), so simply saying what the map becomes is sufficient to determine the rest of the new state, and the partition constraint remains true.

%=============================================================================
\section{Subsystems}

\clearpage
\begin{flushleft}
\begin{thebibliography}{99}   % `99' is a picture of the generated numeric references -- they are two digits in this bibliography

%%  Example bibliography entry:
%\bibitem{knuth76} % citation callout, e.g.: \cite{knuth76}
%  Donald E. Knuth, % author
%  \emph{The computer as Master Mind}. % title
%  J. Recreational Mathematics, Vol.~9(1), 1976-1977. % publisher, or journal, volume and date

\bibitem{warden}
  Various authors,
  \emph{Warden github repository},
  \texttt{https://github.com/cloudfoundry/warden}.

\bibitem{garden}
  Various authors,
  \emph{Garden github repository}, 
  \texttt{https://github.com/pivotal-cf-experimental/garden}.

% API abstracting the cgroup filesystem
% See http://manpages.ubuntu.com/manpages/lucid/man5/cgconfig.conf.5.html for configuration containing useful insights
\bibitem{libcgroup}
  Various authors
  \emph{libcgroup},
  \texttt{http://libcg.sourceforge.net/html/index.html}.

\bibitem{linuxgroups}
  Paul Menage, Paul Jackson and Christoph Lameter,
  \emph{CGROUPS},
  \texttt{https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt}, 2004-2006.

\bibitem{linuxkernel}
  Linus Torvalds, \emph{et al},
  \emph{Linux kernel source tree},
  \texttt{https://github.com/torvalds/linux}.

\bibitem{memory}
  Various authors,
  \emph{Memory Resource Controller},
  \texttt{https://www.kernel.org/doc/Documentation/cgroups/memory.txt}.

\bibitem{noop}
  Kamezawa Hiroyuki, \emph{et al},
  \emph{NOOP cgroup subsystem},
  \texttt{http://thread.gmane.org/gmane.linux.kernel/777763}.

\bibitem{rharticle}
  Martin Prpi\u{c}, R\"udiger Landmann, and Douglas Silas,
  \emph{Red Hat Enterprise Linux 6.5 GA: Resource Management Guide}, 
  \texttt{https://access.redhat.com/site/documentation/en-US\slash{}Red\_Hat\_Enterprise\_Linux/6/pdf/Resource\_Management\_Guide\slash{}Red\_Hat\_Enterprise\_Linux-6-Resource\_Management\_Guide-en-US.pdf}.

\end{thebibliography}
\end{flushleft}
\end{document}
